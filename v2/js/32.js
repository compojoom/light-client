(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[32],{

/***/ "../node_modules/pouchdb-adapter-indexeddb/lib/index.es.js":
/*!*****************************************************************!*\
  !*** ../node_modules/pouchdb-adapter-indexeddb/lib/index.es.js ***!
  \*****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var pouchdb_binary_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pouchdb-binary-utils */ \"../node_modules/pouchdb-binary-utils/lib/index-browser.es.js\");\n/* harmony import */ var pouchdb_adapter_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pouchdb-adapter-utils */ \"../node_modules/pouchdb-adapter-utils/lib/index.es.js\");\n/* harmony import */ var pouchdb_md5__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! pouchdb-md5 */ \"../node_modules/pouchdb-md5/lib/index-browser.es.js\");\n/* harmony import */ var pouchdb_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! pouchdb-utils */ \"../node_modules/pouchdb-utils/lib/index-browser.es.js\");\n/* harmony import */ var pouchdb_errors__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! pouchdb-errors */ \"../node_modules/pouchdb-errors/lib/index.es.js\");\n/* harmony import */ var pouchdb_merge__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! pouchdb-merge */ \"../node_modules/pouchdb-merge/lib/index.es.js\");\n\n\n\n\n\n\n\nvar IDB_NULL = Number.MIN_SAFE_INTEGER;\nvar IDB_FALSE = Number.MIN_SAFE_INTEGER + 1;\nvar IDB_TRUE = Number.MIN_SAFE_INTEGER + 2;\n\n// These are the same as bellow but without the global flag\n// we want to use RegExp.test because it's really fast, but the global flag\n// makes the regex const stateful (seriously) as it walked through all instances\nvar TEST_KEY_INVALID = /^[^a-zA-Z_$]|[^a-zA-Z0-9_$]+/;\nvar TEST_PATH_INVALID = /\\\\.|(^|\\.)[^a-zA-Z_$]|[^a-zA-Z0-9_$.]+/;\nfunction needsSanitise(name, isPath) {\n  if (isPath) {\n    return TEST_PATH_INVALID.test(name);\n  } else {\n    return TEST_KEY_INVALID.test(name);\n  }\n}\n\n//\n// IndexedDB only allows valid JS names in its index paths, whereas JSON allows\n// for any string at all. This converts invalid JS names to valid ones, to allow\n// for them to be indexed.\n//\n// For example, \"foo-bar\" is a valid JSON key, but cannot be a valid JS name\n// (because that would be read as foo minus bar).\n//\n// Very high level rules for valid JS names are:\n//  - First character cannot start with a number\n//  - Otherwise all characters must be be a-z, A-Z, 0-9, $ or _.\n//  - We allow . unless the name represents a single field, as that represents\n//    a deep index path.\n//\n// This is more aggressive than it needs to be, but also simpler.\n//\nvar KEY_INVALID = new RegExp(TEST_KEY_INVALID.source, 'g');\nvar PATH_INVALID = new RegExp(TEST_PATH_INVALID.source, 'g');\nvar SLASH = '\\\\'.charCodeAt(0);\nconst IS_DOT = '.'.charCodeAt(0);\n\nfunction sanitise(name, isPath) {\n  var correctCharacters = function (match) {\n    var good = '';\n    for (var i = 0; i < match.length; i++) {\n      var code = match.charCodeAt(i);\n      // If you're sanitising a path, a slash character is there to be interpreted\n      // by whatever parses the path later as \"escape the next thing\".\n      //\n      // e.g., if you want to index THIS string:\n      //   {\"foo\": {\"bar.baz\": \"THIS\"}}\n      // Your index path would be \"foo.bar\\.baz\".\n\n      if (code === IS_DOT && isPath && i === 0) {\n        good += '.';\n      } else if (code === SLASH && isPath) {\n        continue;\n      } else {\n        good += '_c' + code + '_';\n      }\n    }\n    return good;\n  };\n\n  if (isPath) {\n    return name.replace(PATH_INVALID, correctCharacters);\n  } else {\n    return name.replace(KEY_INVALID, correctCharacters);\n  }\n}\n\nfunction needsRewrite(data) {\n  for (var key of Object.keys(data)) {\n    if (needsSanitise(key)) {\n      return true;\n    } else if (data[key] === null || typeof data[key] === 'boolean') {\n      return true;\n    } else if (typeof data[key] === 'object') {\n      return needsRewrite(data[key]);\n    }\n  }\n}\n\nfunction rewrite(data) {\n  if (!needsRewrite(data)) {\n    return false;\n  }\n\n  var isArray = Array.isArray(data);\n  var clone = isArray\n    ? []\n    : {};\n\n  Object.keys(data).forEach(function (key) {\n    var safeKey = isArray ? key : sanitise(key);\n\n    if (data[key] === null) {\n      clone[safeKey] = IDB_NULL;\n    } else if (typeof data[key] === 'boolean') {\n      clone[safeKey] = data[key] ? IDB_TRUE : IDB_FALSE;\n    } else if (typeof data[key] === 'object') {\n      clone[safeKey] = rewrite(data[key]);\n    } else {\n      clone[safeKey] = data[key];\n    }\n  });\n\n  return clone;\n}\n\nvar DOC_STORE = 'docs';\nvar META_STORE = 'meta';\n\nfunction idbError(callback) {\n  return function (evt) {\n    var message = 'unknown_error';\n    if (evt.target && evt.target.error) {\n      message = evt.target.error.name || evt.target.error.message;\n    }\n    callback(Object(pouchdb_errors__WEBPACK_IMPORTED_MODULE_4__[\"createError\"])(pouchdb_errors__WEBPACK_IMPORTED_MODULE_4__[\"IDB_ERROR\"], message, evt.type));\n  };\n}\n\nfunction processAttachment(name, src, doc, isBinary) {\n\n  delete doc._attachments[name].stub;\n\n  if (isBinary) {\n    doc._attachments[name].data =\n      src.attachments[doc._attachments[name].digest].data;\n    return Promise.resolve();\n  }\n\n  return new Promise(function (resolve) {\n    var data = src.attachments[doc._attachments[name].digest].data;\n    Object(pouchdb_binary_utils__WEBPACK_IMPORTED_MODULE_0__[\"readAsBinaryString\"])(data, function (binString) {\n      doc._attachments[name].data = Object(pouchdb_binary_utils__WEBPACK_IMPORTED_MODULE_0__[\"btoa\"])(binString);\n      delete doc._attachments[name].length;\n      resolve();\n    });\n  });\n}\n\nfunction rawIndexFields(ddoc, viewName) {\n  // fields are an array of either the string name of the field, or a key value\n  var fields = ddoc.views[viewName].options &&\n               ddoc.views[viewName].options.def &&\n               ddoc.views[viewName].options.def.fields || [];\n\n  // Either ['foo'] or [{'foo': 'desc'}]\n  return fields.map(function (field) {\n    if (typeof field === 'string') {\n      return field;\n    } else {\n      return Object.keys(field)[0];\n    }\n  });\n}\n\nfunction naturalIndexName(fields) {\n  return '_find_idx/' + fields.join('/');\n}\n\n/**\n * Convert the fields the user gave us in the view and convert them to work for\n * indexeddb.\n *\n * fields is an array of field strings. A field string could be one field:\n *   'foo'\n * Or it could be a json path:\n *   'foo.bar'\n */\nfunction correctIndexFields(fields) {\n  // Every index has to have deleted at the front, because when we do a query\n  // we need to filter out deleted documents.\n  return ['deleted'].concat(\n    fields.map(function (field) {\n      if (field in ['_id', '_rev', '_deleted', '_attachments']) {\n        // These properties are stored at the top level without the underscore\n        return field.substr(1);\n      } else {\n        // The custom document fields are inside the `data` property\n        return 'data.' + sanitise(field, true);\n      }\n    })\n  );\n}\n\n//\n// Core PouchDB schema version. Increment this if we, as a library, want to make\n// schema changes in indexeddb. See upgradePouchDbSchema()\n//\nvar POUCHDB_IDB_VERSION = 1;\n\n//\n// Functions that manage a combinate indexeddb version, by combining the current\n// time in millis that represents user migrations with a large multiplier that\n// represents PouchDB system migrations.\n//\n// This lets us use the idb version number to both represent\n// PouchDB-library-level migrations as well as \"user migrations\" required for\n// when design documents trigger the addition or removal of native indexes.\n//\n// Given that Number.MAX_SAFE_INTEGER = 9007199254740991\n//\n// We can easily use the largest 2-3 digits and either allow:\n//  - 900 system migrations up to 2198/02/18\n//  - or 89 system migrations up to 5050/02/14\n//\n// This impl does the former. If this code still exists after 2198 someone send my\n// decendents a Spacebook message congratulating them on their impressive genes.\n//\n// 9007199254740991 <- MAX_SAFE_INTEGER\n//   10000000000000 <- 10^13\n//    7199254740991 <- 2198-02-18T16:59:00.991Z\n//\nvar versionMultiplier = Math.pow(10, 13);\nfunction createIdbVersion() {\n  return (versionMultiplier * POUCHDB_IDB_VERSION) + new Date().getTime();\n}\nfunction getPouchDbVersion(version) {\n  return Math.floor(version / versionMultiplier);\n}\n\nfunction maintainNativeIndexes(openReq, reject) {\n  var docStore = openReq.transaction.objectStore(DOC_STORE);\n  var ddocsReq = docStore.getAll(IDBKeyRange.bound('_design/', '_design/\\uffff'));\n\n  ddocsReq.onsuccess = function (e) {\n    var results = e.target.result;\n    var existingIndexNames = Array.from(docStore.indexNames);\n\n    // NB: the only thing we're supporting here is the declared indexing\n    // fields nothing more.\n    var expectedIndexes = results.filter(function (row) {\n      return row.deleted === 0 && row.revs[row.rev].data.views;\n    }).map(function (row) {\n      return row.revs[row.rev].data;\n    }).reduce(function (indexes, ddoc) {\n      return Object.keys(ddoc.views).reduce(function (acc, viewName) {\n        var fields = rawIndexFields(ddoc, viewName);\n\n        if (fields && fields.length > 0) {\n          acc[naturalIndexName(fields)] = correctIndexFields(fields);\n        }\n\n        return acc;\n      }, indexes);\n    }, {});\n\n    var expectedIndexNames = Object.keys(expectedIndexes);\n\n    // Delete any indexes that aren't system indexes or expected\n    var systemIndexNames = ['seq'];\n    existingIndexNames.forEach(function (index) {\n      if (systemIndexNames.indexOf(index) === -1  && expectedIndexNames.indexOf(index) === -1) {\n        docStore.deleteIndex(index);\n      }\n    });\n\n    // Work out which indexes are missing and create them\n    var newIndexNames = expectedIndexNames.filter(function (ei) {\n      return existingIndexNames.indexOf(ei) === -1;\n    });\n\n    try {\n      newIndexNames.forEach(function (indexName) {\n        docStore.createIndex(indexName, expectedIndexes[indexName]);\n      });\n    } catch (err) {\n      reject(err);\n    }\n  };\n}\n\nfunction upgradePouchDbSchema(db, pouchdbVersion) {\n  if (pouchdbVersion < 1) {\n    var docStore = db.createObjectStore(DOC_STORE, {keyPath : 'id'});\n    docStore.createIndex('seq', 'seq', {unique: true});\n\n    db.createObjectStore(META_STORE, {keyPath: 'id'});\n  }\n\n  // Declare more PouchDB schema changes here\n  // if (pouchdbVersion < 2) { .. }\n}\n\nfunction openDatabase(openDatabases, api, opts, resolve, reject) {\n  var openReq = opts.versionchanged ?\n    indexedDB.open(opts.name) :\n    indexedDB.open(opts.name, createIdbVersion());\n\n  openReq.onupgradeneeded = function (e) {\n    if (e.oldVersion > 0 && e.oldVersion < versionMultiplier) {\n      // This DB was created with the \"idb\" adapter, **not** this one.\n      // For now we're going to just error out here: users must manually\n      // migrate between the two. In the future, dependent on performance tests,\n      // we might silently migrate\n      throw new Error('Incorrect adapter: you should specify the \"idb\" adapter to open this DB');\n    } else if (e.oldVersion === 0 && e.newVersion < versionMultiplier) {\n      // Firefox still creates the database with version=1 even if we throw,\n      // so we need to be sure to destroy the empty database before throwing\n      indexedDB.deleteDatabase(opts.name);\n      throw new Error('Database was deleted while open');\n    }\n\n    var db = e.target.result;\n\n    var pouchdbVersion = getPouchDbVersion(e.oldVersion);\n    upgradePouchDbSchema(db, pouchdbVersion);\n    maintainNativeIndexes(openReq, reject);\n  };\n\n  openReq.onblocked = function (e) {\n      // AFAICT this only occurs if, after sending `onversionchange` events to\n      // all other open DBs (ie in different tabs), there are still open\n      // connections to the DB. In this code we should never see this because we\n      // close our DBs on these events, and all DB interactions are wrapped in\n      // safely re-opening the DB.\n      console.error('onblocked, this should never happen', e);\n  };\n\n  openReq.onsuccess = function (e) {\n    var idb = e.target.result;\n\n    idb.onabort = function (e) {\n      console.error('Database has a global failure', e.target.error);\n      delete openDatabases[opts.name];\n      idb.close();\n    };\n\n    idb.onversionchange = function () {\n      console.log('Database was made stale, closing handle');\n      openDatabases[opts.name].versionchanged = true;\n      idb.close();\n    };\n\n    idb.onclose = function () {\n      console.log('Database was made stale, closing handle');\n      if (opts.name in openDatabases) {\n        openDatabases[opts.name].versionchanged = true;\n      }\n    };\n\n    var metadata = {id: META_STORE};\n    var txn = idb.transaction([META_STORE], 'readwrite');\n\n    txn.oncomplete = function () {\n      resolve({idb: idb, metadata: metadata});\n    };\n\n    var metaStore = txn.objectStore(META_STORE);\n    metaStore.get(META_STORE).onsuccess = function (e) {\n      metadata = e.target.result || metadata;\n      var changed = false;\n\n      if (!('doc_count' in metadata)) {\n        changed = true;\n        metadata.doc_count = 0;\n      }\n\n      if (!('seq' in metadata)) {\n        changed = true;\n        metadata.seq = 0;\n      }\n\n      if (!('db_uuid' in metadata)) {\n        changed = true;\n        metadata.db_uuid = Object(pouchdb_utils__WEBPACK_IMPORTED_MODULE_3__[\"uuid\"])();\n      }\n\n      if (changed) {\n        metaStore.put(metadata);\n      }\n    };\n  };\n\n  openReq.onerror = function (e) {\n    reject(e.target.error);\n  };\n}\n\nfunction setup (openDatabases, api, opts) {\n  if (!openDatabases[opts.name] || openDatabases[opts.name].versionchanged) {\n    opts.versionchanged = openDatabases[opts.name] &&\n                          openDatabases[opts.name].versionchanged;\n\n    openDatabases[opts.name] = new Promise(function (resolve, reject) {\n      openDatabase(openDatabases, api, opts, resolve, reject);\n    });\n  }\n\n  return openDatabases[opts.name];\n}\n\nfunction info (metadata, callback) {\n  callback(null, {\n    doc_count: metadata.doc_count,\n    update_seq: metadata.seq\n  });\n}\n\nfunction get (txn, id, opts, callback) {\n  if (txn.error) {\n    return callback(txn.error);\n  }\n\n  txn.txn.objectStore(DOC_STORE).get(id).onsuccess = function (e) {\n    var doc = e.target.result;\n    var rev;\n    if (!opts.rev) {\n      rev = (doc && doc.rev);\n    } else {\n      rev = opts.latest ? Object(pouchdb_merge__WEBPACK_IMPORTED_MODULE_5__[\"latest\"])(opts.rev, doc) : opts.rev;\n    }\n\n    if (!doc || (doc.deleted && !opts.rev) || !(rev in doc.revs)) {\n      callback(Object(pouchdb_errors__WEBPACK_IMPORTED_MODULE_4__[\"createError\"])(pouchdb_errors__WEBPACK_IMPORTED_MODULE_4__[\"MISSING_DOC\"], 'missing'));\n      return;\n    }\n\n    var result = doc.revs[rev].data;\n    result._id = doc.id;\n    result._rev = rev;\n\n    // WARNING: expecting possible old format\n    // TODO: why are we passing the transaction in the context?\n    //       It's not clear we ever thread these txns usefully\n    callback(null, {\n      doc: result,\n      metadata: doc,\n      ctx: txn\n    });\n  };\n}\n\nfunction parseAttachment(attachment, opts, cb) {\n  if (opts.binary) {\n    return cb(null, attachment);\n  } else {\n    Object(pouchdb_binary_utils__WEBPACK_IMPORTED_MODULE_0__[\"readAsBinaryString\"])(attachment, function (binString) {\n      cb(null, Object(pouchdb_binary_utils__WEBPACK_IMPORTED_MODULE_0__[\"btoa\"])(binString));\n    });\n  }\n}\n\nfunction getAttachment(txn, docId, attachId, _, opts, cb) {\n  if (txn.error) {\n    return cb(txn.error);\n  }\n\n  var attachment;\n\n  txn.txn.objectStore(DOC_STORE).get(docId).onsuccess = function (e) {\n    var doc = e.target.result;\n    var rev = doc.revs[opts.rev || doc.rev].data;\n    var digest = rev._attachments[attachId].digest;\n    attachment = doc.attachments[digest].data;\n  };\n\n  txn.txn.oncomplete = function () {\n    parseAttachment(attachment, opts, cb);\n  };\n\n  txn.txn.onabort = cb;\n}\n\nfunction bulkDocs (api, req, opts, metadata, dbOpts, idbChanges, callback) {\n\n  var txn;\n\n  // TODO: I would prefer to get rid of these globals\n  var error;\n  var results = [];\n  var docs = [];\n  var lastWriteIndex;\n\n  var revsLimit = dbOpts.revs_limit || 1000;\n  var rewriteEnabled = dbOpts.name.indexOf(\"-mrview-\") === -1;\n  const autoCompaction = dbOpts.auto_compaction;\n\n  // We only need to track 1 revision for local documents\n  function docsRevsLimit(doc) {\n    return /^_local/.test(doc.id) ? 1 : revsLimit;\n  }\n\n  function rootIsMissing(doc) {\n    return doc.rev_tree[0].ids[1].status === 'missing';\n  }\n\n  function parseBase64(data) {\n    try {\n      return atob(data);\n    } catch (e) {\n      return {\n        error: Object(pouchdb_errors__WEBPACK_IMPORTED_MODULE_4__[\"createError\"])(pouchdb_errors__WEBPACK_IMPORTED_MODULE_4__[\"BAD_ARG\"], 'Attachment is not a valid base64 string')\n      };\n    }\n  }\n\n  // Reads the original doc from the store if available\n  // As in allDocs with keys option using multiple get calls is the fastest way\n  function fetchExistingDocs(txn, docs) {\n    var fetched = 0;\n    var oldDocs = {};\n\n    function readDone(e) {\n      if (e.target.result) {\n        oldDocs[e.target.result.id] = e.target.result;\n      }\n      if (++fetched === docs.length) {\n        processDocs(txn, docs, oldDocs);\n      }\n    }\n\n    docs.forEach(function (doc) {\n      txn.objectStore(DOC_STORE).get(doc.id).onsuccess = readDone;\n    });\n  }\n\n  function revHasAttachment(doc, rev, digest) {\n    return doc.revs[rev] &&\n      doc.revs[rev].data._attachments &&\n      Object.values(doc.revs[rev].data._attachments).find(function (att) {\n        return att.digest === digest;\n      });\n  }\n\n  function processDocs(txn, docs, oldDocs) {\n\n    docs.forEach(function (doc, i) {\n      var newDoc;\n\n      // The first document write cannot be a deletion\n      if ('was_delete' in opts && !(Object.prototype.hasOwnProperty.call(oldDocs, doc.id))) {\n        newDoc = Object(pouchdb_errors__WEBPACK_IMPORTED_MODULE_4__[\"createError\"])(pouchdb_errors__WEBPACK_IMPORTED_MODULE_4__[\"MISSING_DOC\"], 'deleted');\n\n      // The first write of a document cannot specify a revision\n      } else if (opts.new_edits &&\n                 !Object.prototype.hasOwnProperty.call(oldDocs, doc.id) &&\n                 rootIsMissing(doc)) {\n        newDoc = Object(pouchdb_errors__WEBPACK_IMPORTED_MODULE_4__[\"createError\"])(pouchdb_errors__WEBPACK_IMPORTED_MODULE_4__[\"REV_CONFLICT\"]);\n\n      // Update the existing document\n      } else if (Object.prototype.hasOwnProperty.call(oldDocs, doc.id)) {\n        newDoc = update(txn, doc, oldDocs[doc.id]);\n        // The update can be rejected if it is an update to an existing\n        // revision, if so skip it\n        if (newDoc == false) {\n          return;\n        }\n\n      // New document\n      } else {\n        // Ensure new documents are also stemmed\n        var merged = Object(pouchdb_merge__WEBPACK_IMPORTED_MODULE_5__[\"merge\"])([], doc.rev_tree[0], docsRevsLimit(doc));\n        doc.rev_tree = merged.tree;\n        doc.stemmedRevs = merged.stemmedRevs;\n        newDoc = doc;\n        newDoc.isNewDoc = true;\n        newDoc.wasDeleted = doc.revs[doc.rev].deleted ? 1 : 0;\n      }\n\n      if (newDoc.error) {\n        results[i] = newDoc;\n      } else {\n        oldDocs[newDoc.id] = newDoc;\n        lastWriteIndex = i;\n        write(txn, newDoc, i);\n      }\n    });\n  }\n\n  // Converts from the format returned by parseDoc into the new format\n  // we use to store\n  function convertDocFormat(doc) {\n\n    var newDoc = {\n      id: doc.metadata.id,\n      rev: doc.metadata.rev,\n      rev_tree: doc.metadata.rev_tree,\n      revs: doc.metadata.revs || {}\n    };\n\n    newDoc.revs[newDoc.rev] = {\n      data: doc.data,\n      deleted: doc.metadata.deleted\n    };\n\n    return newDoc;\n  }\n\n  function update(txn, doc, oldDoc) {\n\n    // Ignore updates to existing revisions\n    if ((doc.rev in oldDoc.revs) && !opts.new_edits) {\n      return false;\n    }\n\n    var isRoot = /^1-/.test(doc.rev);\n\n    // Reattach first writes after a deletion to last deleted tree\n    if (oldDoc.deleted && !doc.deleted && opts.new_edits && isRoot) {\n      var tmp = doc.revs[doc.rev].data;\n      tmp._rev = oldDoc.rev;\n      tmp._id = oldDoc.id;\n      doc = convertDocFormat(Object(pouchdb_adapter_utils__WEBPACK_IMPORTED_MODULE_1__[\"parseDoc\"])(tmp, opts.new_edits, dbOpts));\n    }\n\n    var merged = Object(pouchdb_merge__WEBPACK_IMPORTED_MODULE_5__[\"merge\"])(oldDoc.rev_tree, doc.rev_tree[0], docsRevsLimit(doc));\n    doc.stemmedRevs = merged.stemmedRevs;\n    doc.rev_tree = merged.tree;\n\n    // Merge the old and new rev data\n    var revs = oldDoc.revs;\n    revs[doc.rev] = doc.revs[doc.rev];\n    doc.revs = revs;\n\n    doc.attachments = oldDoc.attachments;\n\n    var inConflict = opts.new_edits && (((oldDoc.deleted && doc.deleted) ||\n       (!oldDoc.deleted && merged.conflicts !== 'new_leaf') ||\n       (oldDoc.deleted && !doc.deleted && merged.conflicts === 'new_branch') ||\n       (oldDoc.rev === doc.rev)));\n\n    if (inConflict) {\n      return Object(pouchdb_errors__WEBPACK_IMPORTED_MODULE_4__[\"createError\"])(pouchdb_errors__WEBPACK_IMPORTED_MODULE_4__[\"REV_CONFLICT\"]);\n    }\n\n    doc.wasDeleted = oldDoc.deleted;\n\n    return doc;\n  }\n\n  function write(txn, doc, i) {\n\n    // We copy the data from the winning revision into the root\n    // of the document so that it can be indexed\n    var winningRev$$1 = Object(pouchdb_merge__WEBPACK_IMPORTED_MODULE_5__[\"winningRev\"])(doc);\n    // rev of new doc for attachments and to return it\n    var writtenRev = doc.rev;\n    var isLocal = /^_local/.test(doc.id);\n\n    var theDoc = doc.revs[winningRev$$1].data;\n\n    const isNewDoc = doc.isNewDoc;\n\n    if (rewriteEnabled) {\n      // doc.data is what we index, so we need to clone and rewrite it, and clean\n      // it up for indexability\n      var result = rewrite(theDoc);\n      if (result) {\n        doc.data = result;\n        delete doc.data._attachments;\n      } else {\n        doc.data = theDoc;\n      }\n    } else {\n      doc.data = theDoc;\n    }\n\n    doc.rev = winningRev$$1;\n    // .deleted needs to be an int for indexing\n    doc.deleted = doc.revs[winningRev$$1].deleted ? 1 : 0;\n\n    // Bump the seq for every new (non local) revision written\n    // TODO: index expects a unique seq, not sure if ignoring local will\n    // work\n    if (!isLocal) {\n      doc.seq = ++metadata.seq;\n\n      var delta = 0;\n      // If its a new document, we wont decrement if deleted\n      if (doc.isNewDoc) {\n        delta = doc.deleted ? 0 : 1;\n      } else if (doc.wasDeleted !== doc.deleted) {\n        delta = doc.deleted ? -1 : 1;\n      }\n      metadata.doc_count += delta;\n    }\n    delete doc.isNewDoc;\n    delete doc.wasDeleted;\n\n    // If there have been revisions stemmed when merging trees,\n    // delete their data\n    let revsToDelete = doc.stemmedRevs || [];\n\n    if (autoCompaction && !isNewDoc) {\n      const result = Object(pouchdb_merge__WEBPACK_IMPORTED_MODULE_5__[\"compactTree\"])(doc);\n      if (result.length) {\n        revsToDelete = revsToDelete.concat(result);\n      }\n    }\n\n    if (revsToDelete.length) {\n      revsToDelete.forEach(function (rev) { delete doc.revs[rev]; });\n    }\n\n    delete doc.stemmedRevs;\n\n    if (!('attachments' in doc)) {\n      doc.attachments = {};\n    }\n\n    if (theDoc._attachments) {\n      for (var k in theDoc._attachments) {\n        var attachment = theDoc._attachments[k];\n        if (attachment.stub) {\n          if (!(attachment.digest in doc.attachments)) {\n            error = Object(pouchdb_errors__WEBPACK_IMPORTED_MODULE_4__[\"createError\"])(pouchdb_errors__WEBPACK_IMPORTED_MODULE_4__[\"MISSING_STUB\"]);\n            // TODO: Not sure how safe this manual abort is, seeing\n            // console issues\n            txn.abort();\n            return;\n          }\n\n          if (revHasAttachment(doc, writtenRev, attachment.digest)) {\n            doc.attachments[attachment.digest].revs[writtenRev] = true;\n          }\n\n        } else {\n\n          doc.attachments[attachment.digest] = attachment;\n          doc.attachments[attachment.digest].revs = {};\n          doc.attachments[attachment.digest].revs[writtenRev] = true;\n\n          theDoc._attachments[k] = {\n            stub: true,\n            digest: attachment.digest,\n            content_type: attachment.content_type,\n            length: attachment.length,\n            revpos: parseInt(writtenRev, 10)\n          };\n        }\n      }\n    }\n\n    // Local documents have different revision handling\n    if (isLocal && doc.deleted) {\n      txn.objectStore(DOC_STORE).delete(doc.id).onsuccess = function () {\n        results[i] = {\n          ok: true,\n          id: doc.id,\n          rev: '0-0'\n        };\n      };\n      updateSeq(i);\n      return;\n    }\n\n    txn.objectStore(DOC_STORE).put(doc).onsuccess = function () {\n      results[i] = {\n        ok: true,\n        id: doc.id,\n        rev: writtenRev\n      };\n      updateSeq(i);\n    };\n  }\n\n  function updateSeq(i) {\n    if (i === lastWriteIndex) {\n      txn.objectStore(META_STORE).put(metadata);\n    }\n  }\n\n  function preProcessAttachment(attachment) {\n    if (attachment.stub) {\n      return Promise.resolve(attachment);\n    }\n\n    var binData;\n    if (typeof attachment.data === 'string') {\n      binData = parseBase64(attachment.data);\n      if (binData.error) {\n        return Promise.reject(binData.error);\n      }\n      attachment.data = Object(pouchdb_binary_utils__WEBPACK_IMPORTED_MODULE_0__[\"binaryStringToBlobOrBuffer\"])(binData, attachment.content_type);\n    } else {\n      binData = attachment.data;\n    }\n\n    return new Promise(function (resolve) {\n      Object(pouchdb_md5__WEBPACK_IMPORTED_MODULE_2__[\"binaryMd5\"])(binData, function (result) {\n        attachment.digest = 'md5-' + result;\n        attachment.length = binData.size || binData.length || 0;\n        resolve(attachment);\n      });\n    });\n  }\n\n  function preProcessAttachments() {\n    var promises = docs.map(function (doc) {\n      var data = doc.revs[doc.rev].data;\n      if (!data._attachments) {\n        return Promise.resolve(data);\n      }\n      var attachments = Object.keys(data._attachments).map(function (k) {\n        data._attachments[k].name = k;\n        return preProcessAttachment(data._attachments[k]);\n      });\n\n      return Promise.all(attachments).then(function (newAttachments) {\n        var processed = {};\n        newAttachments.forEach(function (attachment) {\n          processed[attachment.name] = attachment;\n          delete attachment.name;\n        });\n        data._attachments = processed;\n        return data;\n      });\n    });\n    return Promise.all(promises);\n  }\n\n  for (var i = 0, len = req.docs.length; i < len; i++) {\n    var result;\n    // TODO: We should get rid of throwing for invalid docs, also not sure\n    // why this is needed in idb-next and not idb\n    try {\n      result = Object(pouchdb_adapter_utils__WEBPACK_IMPORTED_MODULE_1__[\"parseDoc\"])(req.docs[i], opts.new_edits, dbOpts);\n    } catch (err) {\n      result = err;\n    }\n    if (result.error) {\n      return callback(result);\n    }\n\n    // Ideally parseDoc would return data in this format, but it is currently\n    // shared so we need to convert\n    docs.push(convertDocFormat(result));\n  }\n\n  preProcessAttachments().then(function () {\n    api._openTransactionSafely([DOC_STORE, META_STORE], 'readwrite', function (err, _txn) {\n      if (err) {\n        return callback(err);\n      }\n\n      txn = _txn;\n\n      txn.onabort = function () {\n        callback(error || Object(pouchdb_errors__WEBPACK_IMPORTED_MODULE_4__[\"createError\"])(pouchdb_errors__WEBPACK_IMPORTED_MODULE_4__[\"UNKNOWN_ERROR\"], 'transaction was aborted'));\n      };\n      txn.ontimeout = idbError(callback);\n\n      txn.oncomplete = function () {\n        idbChanges.notify(dbOpts.name);\n        callback(null, results);\n      };\n\n      // We would like to use promises here, but idb sucks\n      fetchExistingDocs(txn, docs);\n    });\n  }).catch(function (err) {\n    callback(err);\n  });\n}\n\nfunction allDocsKeys(keys, docStore, allDocsInner) {\n  // It's not guaranted to be returned in right order\n  var valuesBatch = new Array(keys.length);\n  var count = 0;\n  keys.forEach(function (key, index) {\n    docStore.get(key).onsuccess = function (event) {\n      if (event.target.result) {\n      valuesBatch[index] = event.target.result;\n      } else {\n        valuesBatch[index] = {key: key, error: 'not_found'};\n      }\n      count++;\n      if (count === keys.length) {\n        valuesBatch.forEach(function (doc) {\n            allDocsInner(doc);\n        });\n      }\n    };\n  });\n}\n\nfunction createKeyRange(start, end, inclusiveEnd, key, descending) {\n  try {\n    if (start && end) {\n      if (descending) {\n        return IDBKeyRange.bound(end, start, !inclusiveEnd, false);\n      } else {\n        return IDBKeyRange.bound(start, end, false, !inclusiveEnd);\n      }\n    } else if (start) {\n      if (descending) {\n        return IDBKeyRange.upperBound(start);\n      } else {\n        return IDBKeyRange.lowerBound(start);\n      }\n    } else if (end) {\n      if (descending) {\n        return IDBKeyRange.lowerBound(end, !inclusiveEnd);\n      } else {\n        return IDBKeyRange.upperBound(end, !inclusiveEnd);\n      }\n    } else if (key) {\n      return IDBKeyRange.only(key);\n    }\n  } catch (e) {\n    return {error: e};\n  }\n  return null;\n}\n\nfunction handleKeyRangeError(opts, metadata, err, callback) {\n  if (err.name === \"DataError\" && err.code === 0) {\n    // data error, start is less than end\n    var returnVal = {\n      total_rows: metadata.doc_count,\n      offset: opts.skip,\n      rows: []\n    };\n    /* istanbul ignore if */\n    if (opts.update_seq) {\n      returnVal.update_seq = metadata.seq;\n    }\n    return callback(null, returnVal);\n  }\n  callback(Object(pouchdb_errors__WEBPACK_IMPORTED_MODULE_4__[\"createError\"])(pouchdb_errors__WEBPACK_IMPORTED_MODULE_4__[\"IDB_ERROR\"], err.name, err.message));\n}\n\nfunction allDocs (txn, metadata, opts, callback) {\n  if (txn.error) {\n    return callback(txn.error);\n  }\n\n  // TODO: Weird hack, I dont like it\n  if (opts.limit === 0) {\n    var returnVal = {\n      total_rows: metadata.doc_count,\n      offset: opts.skip,\n      rows: []\n    };\n\n    /* istanbul ignore if */\n    if (opts.update_seq) {\n      returnVal.update_seq = metadata.seq;\n    }\n    return callback(null, returnVal);\n  }\n\n  var results = [];\n  var processing = [];\n\n  var start = 'startkey' in opts ? opts.startkey : false;\n  var end = 'endkey' in opts ? opts.endkey : false;\n  var key = 'key' in opts ? opts.key : false;\n  var keys = 'keys' in opts ? opts.keys : false;\n  var skip = opts.skip || 0;\n  var limit = typeof opts.limit === 'number' ? opts.limit : -1;\n  var inclusiveEnd = opts.inclusive_end !== false;\n  var descending = 'descending' in opts && opts.descending ? 'prev' : null;\n\n  var keyRange;\n  if (!keys) {\n    keyRange = createKeyRange(start, end, inclusiveEnd, key, descending);\n    if (keyRange && keyRange.error) {\n      return handleKeyRangeError(opts, metadata, keyRange.error, callback);\n    }\n  }\n\n  var docStore = txn.txn.objectStore(DOC_STORE);\n\n  txn.txn.oncomplete = onTxnComplete;\n\n  if (keys) {\n    return allDocsKeys(opts.keys, docStore, allDocsInner);\n  }\n\n  function include_doc(row, doc) {\n    var docData = doc.revs[doc.rev].data;\n\n    row.doc = docData;\n    row.doc._id = doc.id;\n    row.doc._rev = doc.rev;\n    if (opts.conflicts) {\n      var conflicts = Object(pouchdb_merge__WEBPACK_IMPORTED_MODULE_5__[\"collectConflicts\"])(doc);\n      if (conflicts.length) {\n        row.doc._conflicts = conflicts;\n      }\n    }\n    if (opts.attachments && docData._attachments) {\n      for (var name in docData._attachments) {\n        processing.push(processAttachment(name, doc, row.doc, opts.binary));\n      }\n    }\n  }\n\n  function allDocsInner(doc) {\n    if (doc.error && keys) {\n      // key was not found with \"keys\" requests\n      results.push(doc);\n      return true;\n    }\n\n    var row = {\n      id: doc.id,\n      key: doc.id,\n      value: {\n        rev: doc.rev\n      }\n    };\n\n    var deleted = doc.deleted;\n    if (deleted) {\n      if (keys) {\n        results.push(row);\n        row.value.deleted = true;\n        row.doc = null;\n      }\n    } else if (skip-- <= 0) {\n      results.push(row);\n      if (opts.include_docs) {\n        include_doc(row, doc);\n      }\n      if (--limit === 0) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  function onTxnComplete() {\n    Promise.all(processing).then(function () {\n      var returnVal = {\n        total_rows: metadata.doc_count,\n        offset: 0,\n        rows: results\n      };\n\n      /* istanbul ignore if */\n      if (opts.update_seq) {\n        returnVal.update_seq = metadata.seq;\n      }\n      callback(null, returnVal);\n    });\n  }\n\n  var cursor = descending ?\n    docStore.openCursor(keyRange, descending) :\n    docStore.openCursor(keyRange);\n\n  cursor.onsuccess = function (e) {\n\n    var doc = e.target.result && e.target.result.value;\n\n    // Happens if opts does not have limit,\n    // because cursor will end normally then,\n    // when all docs are retrieved.\n    // Would not be needed, if getAll() optimization was used like in #6059\n    if (!doc) { return; }\n\n    // Skip local docs\n    if (/^_local/.test(doc.id)) {\n      return e.target.result.continue();\n    }\n\n    var continueCursor = allDocsInner(doc);\n    if (continueCursor) {\n      e.target.result.continue();\n    }\n  };\n\n}\n\nfunction changes (txn, idbChanges, api, dbOpts, opts) {\n  if (txn.error) {\n    return opts.complete(txn.error);\n  }\n\n  if (opts.continuous) {\n    var id = dbOpts.name + ':' + Object(pouchdb_utils__WEBPACK_IMPORTED_MODULE_3__[\"uuid\"])();\n    idbChanges.addListener(dbOpts.name, id, api, opts);\n    idbChanges.notify(dbOpts.name);\n    return {\n      cancel: function () {\n        idbChanges.removeListener(dbOpts.name, id);\n      }\n    };\n  }\n\n  var limit = 'limit' in opts ? opts.limit : -1;\n  if (limit === 0) {\n    limit = 1;\n  }\n\n  var store = txn.txn.objectStore(DOC_STORE).index('seq');\n\n  var filter = Object(pouchdb_utils__WEBPACK_IMPORTED_MODULE_3__[\"filterChange\"])(opts);\n  var received = 0;\n\n  var lastSeq = opts.since || 0;\n  var results = [];\n\n  var processing = [];\n\n  function onReqSuccess(e) {\n    if (!e.target.result) { return; }\n    var cursor = e.target.result;\n    var doc = cursor.value;\n    // Overwrite doc.data, which may have been rewritten (see rewrite.js) with\n    // the clean version for that rev\n    doc.data = doc.revs[doc.rev].data;\n    doc.data._id = doc.id;\n    doc.data._rev = doc.rev;\n    if (doc.deleted) {\n      doc.data._deleted = true;\n    }\n\n    if (opts.doc_ids && opts.doc_ids.indexOf(doc.id) === -1) {\n      return cursor.continue();\n    }\n\n    // WARNING: expecting possible old format\n    var change = opts.processChange(doc.data, doc, opts);\n    change.seq = doc.seq;\n    lastSeq = doc.seq;\n    var filtered = filter(change);\n\n    // If its an error\n    if (typeof filtered === 'object') {\n      return opts.complete(filtered);\n    }\n\n    if (filtered) {\n      received++;\n      if (opts.return_docs) {\n        results.push(change);\n      }\n\n      if (opts.include_docs && opts.attachments && doc.data._attachments) {\n        var promises = [];\n        for (var name in doc.data._attachments) {\n          var p = processAttachment(name, doc, change.doc, opts.binary);\n          // We add the processing promise to 2 arrays, one tracks all\n          // the promises needed before we fire onChange, the other\n          // ensure we process all attachments before onComplete\n          promises.push(p);\n          processing.push(p);\n        }\n\n        Promise.all(promises).then(function () {\n          opts.onChange(change);\n        });\n      } else {\n        opts.onChange(change);\n      }\n    }\n    if (received !== limit) {\n      cursor.continue();\n    }\n  }\n\n  function onTxnComplete() {\n    Promise.all(processing).then(function () {\n      opts.complete(null, {\n        results: results,\n        last_seq: lastSeq\n      });\n    });\n  }\n\n  var req;\n  if (opts.descending) {\n    req = store.openCursor(null, 'prev');\n  } else {\n    req = store.openCursor(IDBKeyRange.lowerBound(opts.since, true));\n  }\n\n  txn.txn.oncomplete = onTxnComplete;\n  req.onsuccess = onReqSuccess;\n}\n\nfunction getRevisionTree (txn, id, callback) {\n  if (txn.error) {\n    return callback(txn.error);\n  }\n\n  var req = txn.txn.objectStore(DOC_STORE).get(id);\n  req.onsuccess = function (e) {\n    if (!e.target.result) {\n      callback(Object(pouchdb_errors__WEBPACK_IMPORTED_MODULE_4__[\"createError\"])(pouchdb_errors__WEBPACK_IMPORTED_MODULE_4__[\"MISSING_DOC\"]));\n    } else {\n      callback(null, e.target.result.rev_tree);\n    }\n  };\n}\n\nfunction doCompaction (txn, id, revs, callback) {\n  if (txn.error) {\n    return callback(txn.error);\n  }\n\n  var docStore = txn.txn.objectStore(DOC_STORE);\n\n  docStore.get(id).onsuccess = function (e) {\n    var doc = e.target.result;\n\n    Object(pouchdb_merge__WEBPACK_IMPORTED_MODULE_5__[\"traverseRevTree\"])(doc.rev_tree, function (isLeaf, pos, revHash, ctx, opts) {\n      var rev = pos + '-' + revHash;\n      if (revs.indexOf(rev) !== -1) {\n        opts.status = 'missing';\n      }\n    });\n\n    var attachments = [];\n\n    revs.forEach(function (rev) {\n      if (rev in doc.revs) {\n        // Make a list of attachments that are used by the revisions being\n        // deleted\n        if (doc.revs[rev].data._attachments) {\n          for (var k in doc.revs[rev].data._attachments) {\n            attachments.push(doc.revs[rev].data._attachments[k].digest);\n          }\n        }\n        delete doc.revs[rev];\n      }\n    });\n\n    // Attachments have a list of revisions that are using them, when\n    // that list becomes empty we can delete the attachment.\n    attachments.forEach(function (digest) {\n      revs.forEach(function (rev) {\n        delete doc.attachments[digest].revs[rev];\n      });\n      if (!Object.keys(doc.attachments[digest].revs).length) {\n        delete doc.attachments[digest];\n      }\n    });\n\n    docStore.put(doc);\n  };\n\n  txn.txn.oncomplete = function () {\n    callback();\n  };\n}\n\nfunction destroy (dbOpts, openDatabases, idbChanges, callback) {\n\n  idbChanges.removeAllListeners(dbOpts.name);\n\n  function doDestroy() {\n    var req = indexedDB.deleteDatabase(dbOpts.name);\n    req.onsuccess = function () {\n      delete openDatabases[dbOpts.name];\n      callback(null, {ok: true});\n    };\n  }\n\n  // If the database is open we need to close it\n  if (dbOpts.name in openDatabases) {\n    openDatabases[dbOpts.name].then(function (res) {\n      res.idb.close();\n      doDestroy();\n    });\n  } else {\n    doDestroy();\n  }\n\n}\n\n// Adapted from\n// https://github.com/pouchdb/pouchdb/blob/master/packages/node_modules/pouchdb-find/src/adapters/local/find/query-planner.js#L20-L24\n// This could change / improve in the future?\nvar COUCH_COLLATE_LO = null;\nvar COUCH_COLLATE_HI = '\\uffff'; // actually used as {\"\\uffff\": {}}\n\n// Adapted from: https://www.w3.org/TR/IndexedDB/#compare-two-keys\n// Importantly, *there is no upper bound possible* in idb. The ideal data\n// structure an infintely deep array:\n//   var IDB_COLLATE_HI = []; IDB_COLLATE_HI.push(IDB_COLLATE_HI)\n// But IDBKeyRange is not a fan of shenanigans, so I've just gone with 12 layers\n// because it looks nice and surely that's enough!\nvar IDB_COLLATE_LO = Number.NEGATIVE_INFINITY;\nvar IDB_COLLATE_HI = [[[[[[[[[[[[]]]]]]]]]]]];\n\n//\n// TODO: this should be made offical somewhere and used by AllDocs / get /\n// changes etc as well.\n//\nfunction externaliseRecord(idbDoc) {\n  var doc = idbDoc.revs[idbDoc.rev].data;\n  doc._id = idbDoc.id;\n  doc._rev = idbDoc.rev;\n  if (idbDoc.deleted) {\n    doc._deleted = true;\n  }\n\n  return doc;\n}\n\n/**\n * Generates a keyrange based on the opts passed to query\n *\n * The first key is always 0, as that's how we're filtering out deleted entries.\n */\nfunction generateKeyRange(opts) {\n  function defined(obj, k) {\n    return obj[k] !== void 0;\n  }\n\n  // Converts a valid CouchDB key into a valid IndexedDB one\n  function convert(key, exact) {\n    // The first item in every native index is doc.deleted, and we always want\n    // to only search documents that are not deleted.\n    // \"foo\" -> [0, \"foo\"]\n    var filterDeleted = [0].concat(key);\n\n    return filterDeleted.map(function (k) {\n      // null, true and false are not indexable by indexeddb. When we write\n      // these values we convert them to these constants, and so when we\n      // query for them we need to convert the query also.\n      if (k === null && exact) {\n        // for non-exact queries we treat null as a collate property\n        // see `if (!exact)` block below\n        return IDB_NULL;\n      } else if (k === true) {\n        return IDB_TRUE;\n      } else if (k === false) {\n        return IDB_FALSE;\n      }\n\n      if (!exact) {\n        // We get passed CouchDB's collate low and high values, so for non-exact\n        // ranged queries we're going to convert them to our IDB equivalents\n        if (k === COUCH_COLLATE_LO) {\n          return IDB_COLLATE_LO;\n        } else if (Object.prototype.hasOwnProperty.call(k, COUCH_COLLATE_HI)) {\n          return IDB_COLLATE_HI;\n        }\n      }\n\n      return k;\n    });\n  }\n\n  // CouchDB and so PouchdB defaults to true. We need to make this explicit as\n  // we invert these later for IndexedDB.\n  if (!defined(opts, 'inclusive_end')) {\n    opts.inclusive_end = true;\n  }\n  if (!defined(opts, 'inclusive_start')) {\n    opts.inclusive_start = true;\n  }\n\n  if (opts.descending) {\n    // Flip before generating. We'll check descending again later when performing\n    // an index request\n    var realEndkey = opts.startkey,\n        realInclusiveEnd = opts.inclusive_start;\n\n    opts.startkey = opts.endkey;\n    opts.endkey = realEndkey;\n    opts.inclusive_start = opts.inclusive_end;\n    opts.inclusive_end = realInclusiveEnd;\n  }\n\n  try {\n    if (defined(opts, 'key')) {\n      return IDBKeyRange.only(convert(opts.key, true));\n    }\n\n    if (defined(opts, 'startkey') && !defined(opts, 'endkey')) {\n      return IDBKeyRange.lowerBound(convert(opts.startkey), !opts.inclusive_start);\n    }\n\n    if (!defined(opts, 'startkey') && defined(opts, 'endkey')) {\n      return IDBKeyRange.upperBound(convert(opts.endkey), !opts.inclusive_end);\n    }\n\n    if (defined(opts, 'startkey') && defined(opts, 'endkey')) {\n      return IDBKeyRange.bound(\n        convert(opts.startkey),    convert(opts.endkey),\n        !opts.inclusive_start, !opts.inclusive_end\n      );\n    }\n\n    return IDBKeyRange.only([0]);\n  } catch (err) {\n    console.error('Could not generate keyRange', err, opts);\n    throw Error('Could not generate key range with ' + JSON.stringify(opts));\n  }\n}\n\nfunction getIndexHandle(pdb, fields, reject) {\n  var indexName = naturalIndexName(fields);\n\n  return new Promise(function (resolve) {\n    pdb._openTransactionSafely([DOC_STORE], 'readonly', function (err, txn) {\n      if (err) {\n        return idbError(reject)(err);\n      }\n\n      txn.onabort = idbError(reject);\n      txn.ontimeout = idbError(reject);\n\n      var existingIndexNames = Array.from(txn.objectStore(DOC_STORE).indexNames);\n\n      if (existingIndexNames.indexOf(indexName) === -1) {\n        // The index is missing, force a db restart and try again\n        pdb._freshen()\n          .then(function () { return getIndexHandle(pdb, fields, reject); })\n          .then(resolve);\n      } else {\n        resolve(txn.objectStore(DOC_STORE).index(indexName));\n      }\n    });\n  });\n}\n\n// In theory we should return something like the doc example below, but find\n// only needs rows: [{doc: {...}}], so I think we can just not bother for now\n// {\n//   \"offset\" : 0,\n//   \"rows\": [{\n//     \"id\": \"doc3\",\n//     \"key\": \"Lisa Says\",\n//     \"value\": null,\n//     \"doc\": {\n//       \"_id\": \"doc3\",\n//       \"_rev\": \"1-z\",\n//       \"title\": \"Lisa Says\"\n//     }\n//   }],\n//   \"total_rows\" : 4\n// }\nfunction query(idb, signature, opts) {\n  // At this stage, in the current implementation, find has already gone through\n  // and determined if the index already exists from PouchDB's perspective (eg\n  // there is a design doc for it).\n  //\n  // If we find that the index doesn't exist this means we have to close and\n  // re-open the DB to correct indexes before proceeding, at which point the\n  // index should exist.\n\n  var pdb = this;\n\n  // Assumption, there will be only one /, between the design document name\n  // and the view name.\n  var parts = signature.split('/');\n\n  return new Promise(function (resolve, reject) {\n    pdb.get('_design/' + parts[0]).then(function (ddoc) {\n      var fields = rawIndexFields(ddoc, parts[1]);\n      if (!fields) {\n        throw new Error('ddoc ' + ddoc._id +' with view ' + parts[1] +\n          ' does not have map.options.def.fields defined.');\n      }\n\n      var skip = opts.skip;\n      var limit = Number.isInteger(opts.limit) && opts.limit;\n\n      return getIndexHandle(pdb, fields, reject)\n        .then(function (indexHandle) {\n          var keyRange = generateKeyRange(opts);\n          var req = indexHandle.openCursor(keyRange, opts.descending ? 'prev' : 'next');\n\n          var rows = [];\n          req.onerror = idbError(reject);\n          req.onsuccess = function (e) {\n            var cursor = e.target.result;\n\n            if (!cursor || limit === 0) {\n              return resolve({\n                rows: rows\n              });\n            }\n\n            if (skip) {\n              cursor.advance(skip);\n              skip = false;\n              return;\n            }\n\n            if (limit) {\n              limit = limit - 1;\n            }\n\n            rows.push({doc: externaliseRecord(cursor.value)});\n            cursor.continue();\n          };\n        });\n      })\n      .catch(reject);\n  });\n\n}\n\nfunction viewCleanup() {\n  // I'm not sure we have to do anything here.\n  //\n  // One option is to just close and re-open the DB, which performs the same\n  // action. The only reason you'd want to call this is if you deleted a bunch\n  // of indexes and wanted the space back immediately.\n  //\n  // Otherwise index cleanup happens when:\n  //  - A DB is opened\n  //  - A find query is performed against an index that doesn't exist but should\n\n  return Promise.resolve();\n}\n\nvar ADAPTER_NAME = 'indexeddb';\n\n// TODO: Constructor should be capitalised\nvar idbChanges = new pouchdb_utils__WEBPACK_IMPORTED_MODULE_3__[\"changesHandler\"]();\n\n// A shared list of database handles\nvar openDatabases = {};\n\nfunction IdbPouch(dbOpts, callback) {\n\n  if (dbOpts.view_adapter) {\n    console.log('Please note that the indexeddb adapter manages _find indexes itself, therefore it is not using your specified view_adapter');\n  }\n  \n  var api = this;\n  var metadata = {};\n\n  // Wrapper that gives you an active DB handle. You probably want $t.\n  var $ = function (fun) {\n    return function () {\n      var args = Array.prototype.slice.call(arguments);\n      setup(openDatabases, api, dbOpts).then(function (res) {\n        metadata = res.metadata;\n        args.unshift(res.idb);\n        fun.apply(api, args);\n      }).catch(function (err) {\n        var last = args.pop();\n        if (typeof last === 'function') {\n          last(err);\n        } else {\n          console.error(err);\n        }\n      });\n    };\n  };\n  // the promise version of $\n  var $p = function (fun) {\n    return function () {\n      var args = Array.prototype.slice.call(arguments);\n\n      return setup(openDatabases, api, dbOpts).then(function (res) {\n        metadata = res.metadata;\n        args.unshift(res.idb);\n\n        return fun.apply(api, args);\n      });\n    };\n  };\n  // Wrapper that gives you a safe transaction handle. It's important to use\n  // this instead of opening your own transaction from a db handle got from $,\n  // because in the time between getting the db handle and opening the\n  // transaction it may have been invalidated by index changes.\n  var $t = function (fun, stores, mode) {\n    stores = stores || [DOC_STORE];\n    mode = mode || 'readonly';\n\n    return function () {\n      var args = Array.prototype.slice.call(arguments);\n      var txn = {};\n      setup(openDatabases, api, dbOpts).then(function (res) {\n        metadata = res.metadata;\n        txn.txn = res.idb.transaction(stores, mode);\n      }).catch(function (err) {\n        console.error('Failed to establish transaction safely');\n        console.error(err);\n        txn.error = err;\n      }).then(function () {\n        args.unshift(txn);\n        fun.apply(api, args);\n      });\n    };\n  };\n\n  api._openTransactionSafely = function (stores, mode, callback) {\n    $t(function (txn, callback) {\n      callback(txn.error, txn.txn);\n    }, stores, mode)(callback);\n  };\n\n  api._remote = false;\n  api.type = function () { return ADAPTER_NAME; };\n\n  api._id = $(function (_, cb) {\n    cb(null, metadata.db_uuid);\n  });\n\n  api._info = $(function (_, cb) {\n    return info(metadata, cb);\n  });\n\n  api._get = $t(get);\n\n  api._bulkDocs = $(function (_, req, opts, callback) {\n    bulkDocs(api, req, opts, metadata, dbOpts, idbChanges, callback);\n  });\n\n  api._allDocs = $t(function (txn, opts, cb) {\n    allDocs(txn, metadata, opts, cb);\n  });\n\n  api._getAttachment = $t(getAttachment);\n\n  api._changes = $t(function (txn, opts) {\n    changes(txn, idbChanges, api, dbOpts, opts);\n  });\n\n  api._getRevisionTree = $t(getRevisionTree);\n  api._doCompaction = $t(doCompaction, [DOC_STORE], 'readwrite');\n\n  api._customFindAbstractMapper = {\n    query: $p(query),\n    viewCleanup: $p(viewCleanup)\n  };\n\n  api._destroy = function (opts, callback) {\n    return destroy(dbOpts, openDatabases, idbChanges, callback);\n  };\n\n  api._close = $(function (db, cb) {\n    delete openDatabases[dbOpts.name];\n    db.close();\n    cb();\n  });\n\n  // Closing and re-opening the DB re-generates native indexes\n  api._freshen = function () {\n    return new Promise(function (resolve) {\n      api._close(function () {\n        $(resolve)();\n      });\n    });\n  };\n\n  // TODO: this setTimeout seems nasty, if its needed lets\n  // figure out / explain why\n  setTimeout(function () {\n    callback(null, api);\n  });\n}\n\n// TODO: this isnt really valid permanently, just being lazy to start\nIdbPouch.valid = function () {\n  return true;\n};\n\nfunction index (PouchDB) {\n  PouchDB.adapter(ADAPTER_NAME, IdbPouch, true);\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (index);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2stdnVlOi8vLy4uL25vZGVfbW9kdWxlcy9wb3VjaGRiLWFkYXB0ZXItaW5kZXhlZGRiL2xpYi9pbmRleC5lcy5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUE0RjtBQUMzQztBQUNUO0FBQzJCO0FBQ3NEO0FBQ2Y7O0FBRTFHO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixrQkFBa0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGtFQUFXLENBQUMsd0RBQVM7QUFDbEM7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJLCtFQUFr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QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7O0FBRXZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQ0FBaUMsMERBQUk7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxlQUFlLGtFQUFZO0FBQzNCOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSwyQkFBMkIsUUFBUTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGtFQUFXLENBQUMsMERBQVc7QUFDdEMsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsSUFBSSxxRUFBZTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsU0FBUztBQUMvQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msc0JBQXNCOztBQUV0RDtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw0Q0FBNEMsRUFBRTtBQUMzRTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBLHNCQUFzQixNQUFNLEtBQUs7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLHFDQUFxQztBQUM1RDtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHFCQUFxQiw0REFBYzs7QUFFbkM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLDBCQUEwQixxQkFBcUI7O0FBRS9DO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRWUsb0VBQUssRUFBQyIsImZpbGUiOiIuLi9ub2RlX21vZHVsZXMvcG91Y2hkYi1hZGFwdGVyLWluZGV4ZWRkYi9saWIvaW5kZXguZXMuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBidG9hLCByZWFkQXNCaW5hcnlTdHJpbmcsIGJpbmFyeVN0cmluZ1RvQmxvYk9yQnVmZmVyIH0gZnJvbSAncG91Y2hkYi1iaW5hcnktdXRpbHMnO1xuaW1wb3J0IHsgcGFyc2VEb2MgfSBmcm9tICdwb3VjaGRiLWFkYXB0ZXItdXRpbHMnO1xuaW1wb3J0IHsgYmluYXJ5TWQ1IH0gZnJvbSAncG91Y2hkYi1tZDUnO1xuaW1wb3J0IHsgdXVpZCwgZmlsdGVyQ2hhbmdlLCBjaGFuZ2VzSGFuZGxlciB9IGZyb20gJ3BvdWNoZGItdXRpbHMnO1xuaW1wb3J0IHsgY3JlYXRlRXJyb3IsIElEQl9FUlJPUiwgTUlTU0lOR19ET0MsIFJFVl9DT05GTElDVCwgTUlTU0lOR19TVFVCLCBCQURfQVJHLCBVTktOT1dOX0VSUk9SIH0gZnJvbSAncG91Y2hkYi1lcnJvcnMnO1xuaW1wb3J0IHsgbGF0ZXN0LCB3aW5uaW5nUmV2LCBtZXJnZSwgY29tcGFjdFRyZWUsIGNvbGxlY3RDb25mbGljdHMsIHRyYXZlcnNlUmV2VHJlZSB9IGZyb20gJ3BvdWNoZGItbWVyZ2UnO1xuXG52YXIgSURCX05VTEwgPSBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUjtcbnZhciBJREJfRkFMU0UgPSBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUiArIDE7XG52YXIgSURCX1RSVUUgPSBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUiArIDI7XG5cbi8vIFRoZXNlIGFyZSB0aGUgc2FtZSBhcyBiZWxsb3cgYnV0IHdpdGhvdXQgdGhlIGdsb2JhbCBmbGFnXG4vLyB3ZSB3YW50IHRvIHVzZSBSZWdFeHAudGVzdCBiZWNhdXNlIGl0J3MgcmVhbGx5IGZhc3QsIGJ1dCB0aGUgZ2xvYmFsIGZsYWdcbi8vIG1ha2VzIHRoZSByZWdleCBjb25zdCBzdGF0ZWZ1bCAoc2VyaW91c2x5KSBhcyBpdCB3YWxrZWQgdGhyb3VnaCBhbGwgaW5zdGFuY2VzXG52YXIgVEVTVF9LRVlfSU5WQUxJRCA9IC9eW15hLXpBLVpfJF18W15hLXpBLVowLTlfJF0rLztcbnZhciBURVNUX1BBVEhfSU5WQUxJRCA9IC9cXFxcLnwoXnxcXC4pW15hLXpBLVpfJF18W15hLXpBLVowLTlfJC5dKy87XG5mdW5jdGlvbiBuZWVkc1Nhbml0aXNlKG5hbWUsIGlzUGF0aCkge1xuICBpZiAoaXNQYXRoKSB7XG4gICAgcmV0dXJuIFRFU1RfUEFUSF9JTlZBTElELnRlc3QobmFtZSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFRFU1RfS0VZX0lOVkFMSUQudGVzdChuYW1lKTtcbiAgfVxufVxuXG4vL1xuLy8gSW5kZXhlZERCIG9ubHkgYWxsb3dzIHZhbGlkIEpTIG5hbWVzIGluIGl0cyBpbmRleCBwYXRocywgd2hlcmVhcyBKU09OIGFsbG93c1xuLy8gZm9yIGFueSBzdHJpbmcgYXQgYWxsLiBUaGlzIGNvbnZlcnRzIGludmFsaWQgSlMgbmFtZXMgdG8gdmFsaWQgb25lcywgdG8gYWxsb3dcbi8vIGZvciB0aGVtIHRvIGJlIGluZGV4ZWQuXG4vL1xuLy8gRm9yIGV4YW1wbGUsIFwiZm9vLWJhclwiIGlzIGEgdmFsaWQgSlNPTiBrZXksIGJ1dCBjYW5ub3QgYmUgYSB2YWxpZCBKUyBuYW1lXG4vLyAoYmVjYXVzZSB0aGF0IHdvdWxkIGJlIHJlYWQgYXMgZm9vIG1pbnVzIGJhcikuXG4vL1xuLy8gVmVyeSBoaWdoIGxldmVsIHJ1bGVzIGZvciB2YWxpZCBKUyBuYW1lcyBhcmU6XG4vLyAgLSBGaXJzdCBjaGFyYWN0ZXIgY2Fubm90IHN0YXJ0IHdpdGggYSBudW1iZXJcbi8vICAtIE90aGVyd2lzZSBhbGwgY2hhcmFjdGVycyBtdXN0IGJlIGJlIGEteiwgQS1aLCAwLTksICQgb3IgXy5cbi8vICAtIFdlIGFsbG93IC4gdW5sZXNzIHRoZSBuYW1lIHJlcHJlc2VudHMgYSBzaW5nbGUgZmllbGQsIGFzIHRoYXQgcmVwcmVzZW50c1xuLy8gICAgYSBkZWVwIGluZGV4IHBhdGguXG4vL1xuLy8gVGhpcyBpcyBtb3JlIGFnZ3Jlc3NpdmUgdGhhbiBpdCBuZWVkcyB0byBiZSwgYnV0IGFsc28gc2ltcGxlci5cbi8vXG52YXIgS0VZX0lOVkFMSUQgPSBuZXcgUmVnRXhwKFRFU1RfS0VZX0lOVkFMSUQuc291cmNlLCAnZycpO1xudmFyIFBBVEhfSU5WQUxJRCA9IG5ldyBSZWdFeHAoVEVTVF9QQVRIX0lOVkFMSUQuc291cmNlLCAnZycpO1xudmFyIFNMQVNIID0gJ1xcXFwnLmNoYXJDb2RlQXQoMCk7XG5jb25zdCBJU19ET1QgPSAnLicuY2hhckNvZGVBdCgwKTtcblxuZnVuY3Rpb24gc2FuaXRpc2UobmFtZSwgaXNQYXRoKSB7XG4gIHZhciBjb3JyZWN0Q2hhcmFjdGVycyA9IGZ1bmN0aW9uIChtYXRjaCkge1xuICAgIHZhciBnb29kID0gJyc7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXRjaC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNvZGUgPSBtYXRjaC5jaGFyQ29kZUF0KGkpO1xuICAgICAgLy8gSWYgeW91J3JlIHNhbml0aXNpbmcgYSBwYXRoLCBhIHNsYXNoIGNoYXJhY3RlciBpcyB0aGVyZSB0byBiZSBpbnRlcnByZXRlZFxuICAgICAgLy8gYnkgd2hhdGV2ZXIgcGFyc2VzIHRoZSBwYXRoIGxhdGVyIGFzIFwiZXNjYXBlIHRoZSBuZXh0IHRoaW5nXCIuXG4gICAgICAvL1xuICAgICAgLy8gZS5nLiwgaWYgeW91IHdhbnQgdG8gaW5kZXggVEhJUyBzdHJpbmc6XG4gICAgICAvLyAgIHtcImZvb1wiOiB7XCJiYXIuYmF6XCI6IFwiVEhJU1wifX1cbiAgICAgIC8vIFlvdXIgaW5kZXggcGF0aCB3b3VsZCBiZSBcImZvby5iYXJcXC5iYXpcIi5cblxuICAgICAgaWYgKGNvZGUgPT09IElTX0RPVCAmJiBpc1BhdGggJiYgaSA9PT0gMCkge1xuICAgICAgICBnb29kICs9ICcuJztcbiAgICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gU0xBU0ggJiYgaXNQYXRoKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ29vZCArPSAnX2MnICsgY29kZSArICdfJztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGdvb2Q7XG4gIH07XG5cbiAgaWYgKGlzUGF0aCkge1xuICAgIHJldHVybiBuYW1lLnJlcGxhY2UoUEFUSF9JTlZBTElELCBjb3JyZWN0Q2hhcmFjdGVycyk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5hbWUucmVwbGFjZShLRVlfSU5WQUxJRCwgY29ycmVjdENoYXJhY3RlcnMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG5lZWRzUmV3cml0ZShkYXRhKSB7XG4gIGZvciAodmFyIGtleSBvZiBPYmplY3Qua2V5cyhkYXRhKSkge1xuICAgIGlmIChuZWVkc1Nhbml0aXNlKGtleSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAoZGF0YVtrZXldID09PSBudWxsIHx8IHR5cGVvZiBkYXRhW2tleV0gPT09ICdib29sZWFuJykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZGF0YVtrZXldID09PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuIG5lZWRzUmV3cml0ZShkYXRhW2tleV0pO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByZXdyaXRlKGRhdGEpIHtcbiAgaWYgKCFuZWVkc1Jld3JpdGUoZGF0YSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkoZGF0YSk7XG4gIHZhciBjbG9uZSA9IGlzQXJyYXlcbiAgICA/IFtdXG4gICAgOiB7fTtcblxuICBPYmplY3Qua2V5cyhkYXRhKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICB2YXIgc2FmZUtleSA9IGlzQXJyYXkgPyBrZXkgOiBzYW5pdGlzZShrZXkpO1xuXG4gICAgaWYgKGRhdGFba2V5XSA9PT0gbnVsbCkge1xuICAgICAgY2xvbmVbc2FmZUtleV0gPSBJREJfTlVMTDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBkYXRhW2tleV0gPT09ICdib29sZWFuJykge1xuICAgICAgY2xvbmVbc2FmZUtleV0gPSBkYXRhW2tleV0gPyBJREJfVFJVRSA6IElEQl9GQUxTRTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBkYXRhW2tleV0gPT09ICdvYmplY3QnKSB7XG4gICAgICBjbG9uZVtzYWZlS2V5XSA9IHJld3JpdGUoZGF0YVtrZXldKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2xvbmVbc2FmZUtleV0gPSBkYXRhW2tleV07XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gY2xvbmU7XG59XG5cbnZhciBET0NfU1RPUkUgPSAnZG9jcyc7XG52YXIgTUVUQV9TVE9SRSA9ICdtZXRhJztcblxuZnVuY3Rpb24gaWRiRXJyb3IoY2FsbGJhY2spIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChldnQpIHtcbiAgICB2YXIgbWVzc2FnZSA9ICd1bmtub3duX2Vycm9yJztcbiAgICBpZiAoZXZ0LnRhcmdldCAmJiBldnQudGFyZ2V0LmVycm9yKSB7XG4gICAgICBtZXNzYWdlID0gZXZ0LnRhcmdldC5lcnJvci5uYW1lIHx8IGV2dC50YXJnZXQuZXJyb3IubWVzc2FnZTtcbiAgICB9XG4gICAgY2FsbGJhY2soY3JlYXRlRXJyb3IoSURCX0VSUk9SLCBtZXNzYWdlLCBldnQudHlwZSkpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBwcm9jZXNzQXR0YWNobWVudChuYW1lLCBzcmMsIGRvYywgaXNCaW5hcnkpIHtcblxuICBkZWxldGUgZG9jLl9hdHRhY2htZW50c1tuYW1lXS5zdHViO1xuXG4gIGlmIChpc0JpbmFyeSkge1xuICAgIGRvYy5fYXR0YWNobWVudHNbbmFtZV0uZGF0YSA9XG4gICAgICBzcmMuYXR0YWNobWVudHNbZG9jLl9hdHRhY2htZW50c1tuYW1lXS5kaWdlc3RdLmRhdGE7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgdmFyIGRhdGEgPSBzcmMuYXR0YWNobWVudHNbZG9jLl9hdHRhY2htZW50c1tuYW1lXS5kaWdlc3RdLmRhdGE7XG4gICAgcmVhZEFzQmluYXJ5U3RyaW5nKGRhdGEsIGZ1bmN0aW9uIChiaW5TdHJpbmcpIHtcbiAgICAgIGRvYy5fYXR0YWNobWVudHNbbmFtZV0uZGF0YSA9IGJ0b2EoYmluU3RyaW5nKTtcbiAgICAgIGRlbGV0ZSBkb2MuX2F0dGFjaG1lbnRzW25hbWVdLmxlbmd0aDtcbiAgICAgIHJlc29sdmUoKTtcbiAgICB9KTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHJhd0luZGV4RmllbGRzKGRkb2MsIHZpZXdOYW1lKSB7XG4gIC8vIGZpZWxkcyBhcmUgYW4gYXJyYXkgb2YgZWl0aGVyIHRoZSBzdHJpbmcgbmFtZSBvZiB0aGUgZmllbGQsIG9yIGEga2V5IHZhbHVlXG4gIHZhciBmaWVsZHMgPSBkZG9jLnZpZXdzW3ZpZXdOYW1lXS5vcHRpb25zICYmXG4gICAgICAgICAgICAgICBkZG9jLnZpZXdzW3ZpZXdOYW1lXS5vcHRpb25zLmRlZiAmJlxuICAgICAgICAgICAgICAgZGRvYy52aWV3c1t2aWV3TmFtZV0ub3B0aW9ucy5kZWYuZmllbGRzIHx8IFtdO1xuXG4gIC8vIEVpdGhlciBbJ2ZvbyddIG9yIFt7J2Zvbyc6ICdkZXNjJ31dXG4gIHJldHVybiBmaWVsZHMubWFwKGZ1bmN0aW9uIChmaWVsZCkge1xuICAgIGlmICh0eXBlb2YgZmllbGQgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gZmllbGQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBPYmplY3Qua2V5cyhmaWVsZClbMF07XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gbmF0dXJhbEluZGV4TmFtZShmaWVsZHMpIHtcbiAgcmV0dXJuICdfZmluZF9pZHgvJyArIGZpZWxkcy5qb2luKCcvJyk7XG59XG5cbi8qKlxuICogQ29udmVydCB0aGUgZmllbGRzIHRoZSB1c2VyIGdhdmUgdXMgaW4gdGhlIHZpZXcgYW5kIGNvbnZlcnQgdGhlbSB0byB3b3JrIGZvclxuICogaW5kZXhlZGRiLlxuICpcbiAqIGZpZWxkcyBpcyBhbiBhcnJheSBvZiBmaWVsZCBzdHJpbmdzLiBBIGZpZWxkIHN0cmluZyBjb3VsZCBiZSBvbmUgZmllbGQ6XG4gKiAgICdmb28nXG4gKiBPciBpdCBjb3VsZCBiZSBhIGpzb24gcGF0aDpcbiAqICAgJ2Zvby5iYXInXG4gKi9cbmZ1bmN0aW9uIGNvcnJlY3RJbmRleEZpZWxkcyhmaWVsZHMpIHtcbiAgLy8gRXZlcnkgaW5kZXggaGFzIHRvIGhhdmUgZGVsZXRlZCBhdCB0aGUgZnJvbnQsIGJlY2F1c2Ugd2hlbiB3ZSBkbyBhIHF1ZXJ5XG4gIC8vIHdlIG5lZWQgdG8gZmlsdGVyIG91dCBkZWxldGVkIGRvY3VtZW50cy5cbiAgcmV0dXJuIFsnZGVsZXRlZCddLmNvbmNhdChcbiAgICBmaWVsZHMubWFwKGZ1bmN0aW9uIChmaWVsZCkge1xuICAgICAgaWYgKGZpZWxkIGluIFsnX2lkJywgJ19yZXYnLCAnX2RlbGV0ZWQnLCAnX2F0dGFjaG1lbnRzJ10pIHtcbiAgICAgICAgLy8gVGhlc2UgcHJvcGVydGllcyBhcmUgc3RvcmVkIGF0IHRoZSB0b3AgbGV2ZWwgd2l0aG91dCB0aGUgdW5kZXJzY29yZVxuICAgICAgICByZXR1cm4gZmllbGQuc3Vic3RyKDEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVGhlIGN1c3RvbSBkb2N1bWVudCBmaWVsZHMgYXJlIGluc2lkZSB0aGUgYGRhdGFgIHByb3BlcnR5XG4gICAgICAgIHJldHVybiAnZGF0YS4nICsgc2FuaXRpc2UoZmllbGQsIHRydWUpO1xuICAgICAgfVxuICAgIH0pXG4gICk7XG59XG5cbi8vXG4vLyBDb3JlIFBvdWNoREIgc2NoZW1hIHZlcnNpb24uIEluY3JlbWVudCB0aGlzIGlmIHdlLCBhcyBhIGxpYnJhcnksIHdhbnQgdG8gbWFrZVxuLy8gc2NoZW1hIGNoYW5nZXMgaW4gaW5kZXhlZGRiLiBTZWUgdXBncmFkZVBvdWNoRGJTY2hlbWEoKVxuLy9cbnZhciBQT1VDSERCX0lEQl9WRVJTSU9OID0gMTtcblxuLy9cbi8vIEZ1bmN0aW9ucyB0aGF0IG1hbmFnZSBhIGNvbWJpbmF0ZSBpbmRleGVkZGIgdmVyc2lvbiwgYnkgY29tYmluaW5nIHRoZSBjdXJyZW50XG4vLyB0aW1lIGluIG1pbGxpcyB0aGF0IHJlcHJlc2VudHMgdXNlciBtaWdyYXRpb25zIHdpdGggYSBsYXJnZSBtdWx0aXBsaWVyIHRoYXRcbi8vIHJlcHJlc2VudHMgUG91Y2hEQiBzeXN0ZW0gbWlncmF0aW9ucy5cbi8vXG4vLyBUaGlzIGxldHMgdXMgdXNlIHRoZSBpZGIgdmVyc2lvbiBudW1iZXIgdG8gYm90aCByZXByZXNlbnRcbi8vIFBvdWNoREItbGlicmFyeS1sZXZlbCBtaWdyYXRpb25zIGFzIHdlbGwgYXMgXCJ1c2VyIG1pZ3JhdGlvbnNcIiByZXF1aXJlZCBmb3Jcbi8vIHdoZW4gZGVzaWduIGRvY3VtZW50cyB0cmlnZ2VyIHRoZSBhZGRpdGlvbiBvciByZW1vdmFsIG9mIG5hdGl2ZSBpbmRleGVzLlxuLy9cbi8vIEdpdmVuIHRoYXQgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxXG4vL1xuLy8gV2UgY2FuIGVhc2lseSB1c2UgdGhlIGxhcmdlc3QgMi0zIGRpZ2l0cyBhbmQgZWl0aGVyIGFsbG93OlxuLy8gIC0gOTAwIHN5c3RlbSBtaWdyYXRpb25zIHVwIHRvIDIxOTgvMDIvMThcbi8vICAtIG9yIDg5IHN5c3RlbSBtaWdyYXRpb25zIHVwIHRvIDUwNTAvMDIvMTRcbi8vXG4vLyBUaGlzIGltcGwgZG9lcyB0aGUgZm9ybWVyLiBJZiB0aGlzIGNvZGUgc3RpbGwgZXhpc3RzIGFmdGVyIDIxOTggc29tZW9uZSBzZW5kIG15XG4vLyBkZWNlbmRlbnRzIGEgU3BhY2Vib29rIG1lc3NhZ2UgY29uZ3JhdHVsYXRpbmcgdGhlbSBvbiB0aGVpciBpbXByZXNzaXZlIGdlbmVzLlxuLy9cbi8vIDkwMDcxOTkyNTQ3NDA5OTEgPC0gTUFYX1NBRkVfSU5URUdFUlxuLy8gICAxMDAwMDAwMDAwMDAwMCA8LSAxMF4xM1xuLy8gICAgNzE5OTI1NDc0MDk5MSA8LSAyMTk4LTAyLTE4VDE2OjU5OjAwLjk5MVpcbi8vXG52YXIgdmVyc2lvbk11bHRpcGxpZXIgPSBNYXRoLnBvdygxMCwgMTMpO1xuZnVuY3Rpb24gY3JlYXRlSWRiVmVyc2lvbigpIHtcbiAgcmV0dXJuICh2ZXJzaW9uTXVsdGlwbGllciAqIFBPVUNIREJfSURCX1ZFUlNJT04pICsgbmV3IERhdGUoKS5nZXRUaW1lKCk7XG59XG5mdW5jdGlvbiBnZXRQb3VjaERiVmVyc2lvbih2ZXJzaW9uKSB7XG4gIHJldHVybiBNYXRoLmZsb29yKHZlcnNpb24gLyB2ZXJzaW9uTXVsdGlwbGllcik7XG59XG5cbmZ1bmN0aW9uIG1haW50YWluTmF0aXZlSW5kZXhlcyhvcGVuUmVxLCByZWplY3QpIHtcbiAgdmFyIGRvY1N0b3JlID0gb3BlblJlcS50cmFuc2FjdGlvbi5vYmplY3RTdG9yZShET0NfU1RPUkUpO1xuICB2YXIgZGRvY3NSZXEgPSBkb2NTdG9yZS5nZXRBbGwoSURCS2V5UmFuZ2UuYm91bmQoJ19kZXNpZ24vJywgJ19kZXNpZ24vXFx1ZmZmZicpKTtcblxuICBkZG9jc1JlcS5vbnN1Y2Nlc3MgPSBmdW5jdGlvbiAoZSkge1xuICAgIHZhciByZXN1bHRzID0gZS50YXJnZXQucmVzdWx0O1xuICAgIHZhciBleGlzdGluZ0luZGV4TmFtZXMgPSBBcnJheS5mcm9tKGRvY1N0b3JlLmluZGV4TmFtZXMpO1xuXG4gICAgLy8gTkI6IHRoZSBvbmx5IHRoaW5nIHdlJ3JlIHN1cHBvcnRpbmcgaGVyZSBpcyB0aGUgZGVjbGFyZWQgaW5kZXhpbmdcbiAgICAvLyBmaWVsZHMgbm90aGluZyBtb3JlLlxuICAgIHZhciBleHBlY3RlZEluZGV4ZXMgPSByZXN1bHRzLmZpbHRlcihmdW5jdGlvbiAocm93KSB7XG4gICAgICByZXR1cm4gcm93LmRlbGV0ZWQgPT09IDAgJiYgcm93LnJldnNbcm93LnJldl0uZGF0YS52aWV3cztcbiAgICB9KS5tYXAoZnVuY3Rpb24gKHJvdykge1xuICAgICAgcmV0dXJuIHJvdy5yZXZzW3Jvdy5yZXZdLmRhdGE7XG4gICAgfSkucmVkdWNlKGZ1bmN0aW9uIChpbmRleGVzLCBkZG9jKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmtleXMoZGRvYy52aWV3cykucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHZpZXdOYW1lKSB7XG4gICAgICAgIHZhciBmaWVsZHMgPSByYXdJbmRleEZpZWxkcyhkZG9jLCB2aWV3TmFtZSk7XG5cbiAgICAgICAgaWYgKGZpZWxkcyAmJiBmaWVsZHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGFjY1tuYXR1cmFsSW5kZXhOYW1lKGZpZWxkcyldID0gY29ycmVjdEluZGV4RmllbGRzKGZpZWxkcyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgfSwgaW5kZXhlcyk7XG4gICAgfSwge30pO1xuXG4gICAgdmFyIGV4cGVjdGVkSW5kZXhOYW1lcyA9IE9iamVjdC5rZXlzKGV4cGVjdGVkSW5kZXhlcyk7XG5cbiAgICAvLyBEZWxldGUgYW55IGluZGV4ZXMgdGhhdCBhcmVuJ3Qgc3lzdGVtIGluZGV4ZXMgb3IgZXhwZWN0ZWRcbiAgICB2YXIgc3lzdGVtSW5kZXhOYW1lcyA9IFsnc2VxJ107XG4gICAgZXhpc3RpbmdJbmRleE5hbWVzLmZvckVhY2goZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICBpZiAoc3lzdGVtSW5kZXhOYW1lcy5pbmRleE9mKGluZGV4KSA9PT0gLTEgICYmIGV4cGVjdGVkSW5kZXhOYW1lcy5pbmRleE9mKGluZGV4KSA9PT0gLTEpIHtcbiAgICAgICAgZG9jU3RvcmUuZGVsZXRlSW5kZXgoaW5kZXgpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gV29yayBvdXQgd2hpY2ggaW5kZXhlcyBhcmUgbWlzc2luZyBhbmQgY3JlYXRlIHRoZW1cbiAgICB2YXIgbmV3SW5kZXhOYW1lcyA9IGV4cGVjdGVkSW5kZXhOYW1lcy5maWx0ZXIoZnVuY3Rpb24gKGVpKSB7XG4gICAgICByZXR1cm4gZXhpc3RpbmdJbmRleE5hbWVzLmluZGV4T2YoZWkpID09PSAtMTtcbiAgICB9KTtcblxuICAgIHRyeSB7XG4gICAgICBuZXdJbmRleE5hbWVzLmZvckVhY2goZnVuY3Rpb24gKGluZGV4TmFtZSkge1xuICAgICAgICBkb2NTdG9yZS5jcmVhdGVJbmRleChpbmRleE5hbWUsIGV4cGVjdGVkSW5kZXhlc1tpbmRleE5hbWVdKTtcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmVqZWN0KGVycik7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiB1cGdyYWRlUG91Y2hEYlNjaGVtYShkYiwgcG91Y2hkYlZlcnNpb24pIHtcbiAgaWYgKHBvdWNoZGJWZXJzaW9uIDwgMSkge1xuICAgIHZhciBkb2NTdG9yZSA9IGRiLmNyZWF0ZU9iamVjdFN0b3JlKERPQ19TVE9SRSwge2tleVBhdGggOiAnaWQnfSk7XG4gICAgZG9jU3RvcmUuY3JlYXRlSW5kZXgoJ3NlcScsICdzZXEnLCB7dW5pcXVlOiB0cnVlfSk7XG5cbiAgICBkYi5jcmVhdGVPYmplY3RTdG9yZShNRVRBX1NUT1JFLCB7a2V5UGF0aDogJ2lkJ30pO1xuICB9XG5cbiAgLy8gRGVjbGFyZSBtb3JlIFBvdWNoREIgc2NoZW1hIGNoYW5nZXMgaGVyZVxuICAvLyBpZiAocG91Y2hkYlZlcnNpb24gPCAyKSB7IC4uIH1cbn1cblxuZnVuY3Rpb24gb3BlbkRhdGFiYXNlKG9wZW5EYXRhYmFzZXMsIGFwaSwgb3B0cywgcmVzb2x2ZSwgcmVqZWN0KSB7XG4gIHZhciBvcGVuUmVxID0gb3B0cy52ZXJzaW9uY2hhbmdlZCA/XG4gICAgaW5kZXhlZERCLm9wZW4ob3B0cy5uYW1lKSA6XG4gICAgaW5kZXhlZERCLm9wZW4ob3B0cy5uYW1lLCBjcmVhdGVJZGJWZXJzaW9uKCkpO1xuXG4gIG9wZW5SZXEub251cGdyYWRlbmVlZGVkID0gZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoZS5vbGRWZXJzaW9uID4gMCAmJiBlLm9sZFZlcnNpb24gPCB2ZXJzaW9uTXVsdGlwbGllcikge1xuICAgICAgLy8gVGhpcyBEQiB3YXMgY3JlYXRlZCB3aXRoIHRoZSBcImlkYlwiIGFkYXB0ZXIsICoqbm90KiogdGhpcyBvbmUuXG4gICAgICAvLyBGb3Igbm93IHdlJ3JlIGdvaW5nIHRvIGp1c3QgZXJyb3Igb3V0IGhlcmU6IHVzZXJzIG11c3QgbWFudWFsbHlcbiAgICAgIC8vIG1pZ3JhdGUgYmV0d2VlbiB0aGUgdHdvLiBJbiB0aGUgZnV0dXJlLCBkZXBlbmRlbnQgb24gcGVyZm9ybWFuY2UgdGVzdHMsXG4gICAgICAvLyB3ZSBtaWdodCBzaWxlbnRseSBtaWdyYXRlXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0luY29ycmVjdCBhZGFwdGVyOiB5b3Ugc2hvdWxkIHNwZWNpZnkgdGhlIFwiaWRiXCIgYWRhcHRlciB0byBvcGVuIHRoaXMgREInKTtcbiAgICB9IGVsc2UgaWYgKGUub2xkVmVyc2lvbiA9PT0gMCAmJiBlLm5ld1ZlcnNpb24gPCB2ZXJzaW9uTXVsdGlwbGllcikge1xuICAgICAgLy8gRmlyZWZveCBzdGlsbCBjcmVhdGVzIHRoZSBkYXRhYmFzZSB3aXRoIHZlcnNpb249MSBldmVuIGlmIHdlIHRocm93LFxuICAgICAgLy8gc28gd2UgbmVlZCB0byBiZSBzdXJlIHRvIGRlc3Ryb3kgdGhlIGVtcHR5IGRhdGFiYXNlIGJlZm9yZSB0aHJvd2luZ1xuICAgICAgaW5kZXhlZERCLmRlbGV0ZURhdGFiYXNlKG9wdHMubmFtZSk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RhdGFiYXNlIHdhcyBkZWxldGVkIHdoaWxlIG9wZW4nKTtcbiAgICB9XG5cbiAgICB2YXIgZGIgPSBlLnRhcmdldC5yZXN1bHQ7XG5cbiAgICB2YXIgcG91Y2hkYlZlcnNpb24gPSBnZXRQb3VjaERiVmVyc2lvbihlLm9sZFZlcnNpb24pO1xuICAgIHVwZ3JhZGVQb3VjaERiU2NoZW1hKGRiLCBwb3VjaGRiVmVyc2lvbik7XG4gICAgbWFpbnRhaW5OYXRpdmVJbmRleGVzKG9wZW5SZXEsIHJlamVjdCk7XG4gIH07XG5cbiAgb3BlblJlcS5vbmJsb2NrZWQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgLy8gQUZBSUNUIHRoaXMgb25seSBvY2N1cnMgaWYsIGFmdGVyIHNlbmRpbmcgYG9udmVyc2lvbmNoYW5nZWAgZXZlbnRzIHRvXG4gICAgICAvLyBhbGwgb3RoZXIgb3BlbiBEQnMgKGllIGluIGRpZmZlcmVudCB0YWJzKSwgdGhlcmUgYXJlIHN0aWxsIG9wZW5cbiAgICAgIC8vIGNvbm5lY3Rpb25zIHRvIHRoZSBEQi4gSW4gdGhpcyBjb2RlIHdlIHNob3VsZCBuZXZlciBzZWUgdGhpcyBiZWNhdXNlIHdlXG4gICAgICAvLyBjbG9zZSBvdXIgREJzIG9uIHRoZXNlIGV2ZW50cywgYW5kIGFsbCBEQiBpbnRlcmFjdGlvbnMgYXJlIHdyYXBwZWQgaW5cbiAgICAgIC8vIHNhZmVseSByZS1vcGVuaW5nIHRoZSBEQi5cbiAgICAgIGNvbnNvbGUuZXJyb3IoJ29uYmxvY2tlZCwgdGhpcyBzaG91bGQgbmV2ZXIgaGFwcGVuJywgZSk7XG4gIH07XG5cbiAgb3BlblJlcS5vbnN1Y2Nlc3MgPSBmdW5jdGlvbiAoZSkge1xuICAgIHZhciBpZGIgPSBlLnRhcmdldC5yZXN1bHQ7XG5cbiAgICBpZGIub25hYm9ydCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdEYXRhYmFzZSBoYXMgYSBnbG9iYWwgZmFpbHVyZScsIGUudGFyZ2V0LmVycm9yKTtcbiAgICAgIGRlbGV0ZSBvcGVuRGF0YWJhc2VzW29wdHMubmFtZV07XG4gICAgICBpZGIuY2xvc2UoKTtcbiAgICB9O1xuXG4gICAgaWRiLm9udmVyc2lvbmNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdEYXRhYmFzZSB3YXMgbWFkZSBzdGFsZSwgY2xvc2luZyBoYW5kbGUnKTtcbiAgICAgIG9wZW5EYXRhYmFzZXNbb3B0cy5uYW1lXS52ZXJzaW9uY2hhbmdlZCA9IHRydWU7XG4gICAgICBpZGIuY2xvc2UoKTtcbiAgICB9O1xuXG4gICAgaWRiLm9uY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBjb25zb2xlLmxvZygnRGF0YWJhc2Ugd2FzIG1hZGUgc3RhbGUsIGNsb3NpbmcgaGFuZGxlJyk7XG4gICAgICBpZiAob3B0cy5uYW1lIGluIG9wZW5EYXRhYmFzZXMpIHtcbiAgICAgICAgb3BlbkRhdGFiYXNlc1tvcHRzLm5hbWVdLnZlcnNpb25jaGFuZ2VkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIG1ldGFkYXRhID0ge2lkOiBNRVRBX1NUT1JFfTtcbiAgICB2YXIgdHhuID0gaWRiLnRyYW5zYWN0aW9uKFtNRVRBX1NUT1JFXSwgJ3JlYWR3cml0ZScpO1xuXG4gICAgdHhuLm9uY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXNvbHZlKHtpZGI6IGlkYiwgbWV0YWRhdGE6IG1ldGFkYXRhfSk7XG4gICAgfTtcblxuICAgIHZhciBtZXRhU3RvcmUgPSB0eG4ub2JqZWN0U3RvcmUoTUVUQV9TVE9SRSk7XG4gICAgbWV0YVN0b3JlLmdldChNRVRBX1NUT1JFKS5vbnN1Y2Nlc3MgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgbWV0YWRhdGEgPSBlLnRhcmdldC5yZXN1bHQgfHwgbWV0YWRhdGE7XG4gICAgICB2YXIgY2hhbmdlZCA9IGZhbHNlO1xuXG4gICAgICBpZiAoISgnZG9jX2NvdW50JyBpbiBtZXRhZGF0YSkpIHtcbiAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgICAgIG1ldGFkYXRhLmRvY19jb3VudCA9IDA7XG4gICAgICB9XG5cbiAgICAgIGlmICghKCdzZXEnIGluIG1ldGFkYXRhKSkge1xuICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgbWV0YWRhdGEuc2VxID0gMDtcbiAgICAgIH1cblxuICAgICAgaWYgKCEoJ2RiX3V1aWQnIGluIG1ldGFkYXRhKSkge1xuICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgbWV0YWRhdGEuZGJfdXVpZCA9IHV1aWQoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgICAgbWV0YVN0b3JlLnB1dChtZXRhZGF0YSk7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcblxuICBvcGVuUmVxLm9uZXJyb3IgPSBmdW5jdGlvbiAoZSkge1xuICAgIHJlamVjdChlLnRhcmdldC5lcnJvcik7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHNldHVwIChvcGVuRGF0YWJhc2VzLCBhcGksIG9wdHMpIHtcbiAgaWYgKCFvcGVuRGF0YWJhc2VzW29wdHMubmFtZV0gfHwgb3BlbkRhdGFiYXNlc1tvcHRzLm5hbWVdLnZlcnNpb25jaGFuZ2VkKSB7XG4gICAgb3B0cy52ZXJzaW9uY2hhbmdlZCA9IG9wZW5EYXRhYmFzZXNbb3B0cy5uYW1lXSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVuRGF0YWJhc2VzW29wdHMubmFtZV0udmVyc2lvbmNoYW5nZWQ7XG5cbiAgICBvcGVuRGF0YWJhc2VzW29wdHMubmFtZV0gPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICBvcGVuRGF0YWJhc2Uob3BlbkRhdGFiYXNlcywgYXBpLCBvcHRzLCByZXNvbHZlLCByZWplY3QpO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIG9wZW5EYXRhYmFzZXNbb3B0cy5uYW1lXTtcbn1cblxuZnVuY3Rpb24gaW5mbyAobWV0YWRhdGEsIGNhbGxiYWNrKSB7XG4gIGNhbGxiYWNrKG51bGwsIHtcbiAgICBkb2NfY291bnQ6IG1ldGFkYXRhLmRvY19jb3VudCxcbiAgICB1cGRhdGVfc2VxOiBtZXRhZGF0YS5zZXFcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldCAodHhuLCBpZCwgb3B0cywgY2FsbGJhY2spIHtcbiAgaWYgKHR4bi5lcnJvcikge1xuICAgIHJldHVybiBjYWxsYmFjayh0eG4uZXJyb3IpO1xuICB9XG5cbiAgdHhuLnR4bi5vYmplY3RTdG9yZShET0NfU1RPUkUpLmdldChpZCkub25zdWNjZXNzID0gZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgZG9jID0gZS50YXJnZXQucmVzdWx0O1xuICAgIHZhciByZXY7XG4gICAgaWYgKCFvcHRzLnJldikge1xuICAgICAgcmV2ID0gKGRvYyAmJiBkb2MucmV2KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV2ID0gb3B0cy5sYXRlc3QgPyBsYXRlc3Qob3B0cy5yZXYsIGRvYykgOiBvcHRzLnJldjtcbiAgICB9XG5cbiAgICBpZiAoIWRvYyB8fCAoZG9jLmRlbGV0ZWQgJiYgIW9wdHMucmV2KSB8fCAhKHJldiBpbiBkb2MucmV2cykpIHtcbiAgICAgIGNhbGxiYWNrKGNyZWF0ZUVycm9yKE1JU1NJTkdfRE9DLCAnbWlzc2luZycpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcmVzdWx0ID0gZG9jLnJldnNbcmV2XS5kYXRhO1xuICAgIHJlc3VsdC5faWQgPSBkb2MuaWQ7XG4gICAgcmVzdWx0Ll9yZXYgPSByZXY7XG5cbiAgICAvLyBXQVJOSU5HOiBleHBlY3RpbmcgcG9zc2libGUgb2xkIGZvcm1hdFxuICAgIC8vIFRPRE86IHdoeSBhcmUgd2UgcGFzc2luZyB0aGUgdHJhbnNhY3Rpb24gaW4gdGhlIGNvbnRleHQ/XG4gICAgLy8gICAgICAgSXQncyBub3QgY2xlYXIgd2UgZXZlciB0aHJlYWQgdGhlc2UgdHhucyB1c2VmdWxseVxuICAgIGNhbGxiYWNrKG51bGwsIHtcbiAgICAgIGRvYzogcmVzdWx0LFxuICAgICAgbWV0YWRhdGE6IGRvYyxcbiAgICAgIGN0eDogdHhuXG4gICAgfSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHBhcnNlQXR0YWNobWVudChhdHRhY2htZW50LCBvcHRzLCBjYikge1xuICBpZiAob3B0cy5iaW5hcnkpIHtcbiAgICByZXR1cm4gY2IobnVsbCwgYXR0YWNobWVudCk7XG4gIH0gZWxzZSB7XG4gICAgcmVhZEFzQmluYXJ5U3RyaW5nKGF0dGFjaG1lbnQsIGZ1bmN0aW9uIChiaW5TdHJpbmcpIHtcbiAgICAgIGNiKG51bGwsIGJ0b2EoYmluU3RyaW5nKSk7XG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0QXR0YWNobWVudCh0eG4sIGRvY0lkLCBhdHRhY2hJZCwgXywgb3B0cywgY2IpIHtcbiAgaWYgKHR4bi5lcnJvcikge1xuICAgIHJldHVybiBjYih0eG4uZXJyb3IpO1xuICB9XG5cbiAgdmFyIGF0dGFjaG1lbnQ7XG5cbiAgdHhuLnR4bi5vYmplY3RTdG9yZShET0NfU1RPUkUpLmdldChkb2NJZCkub25zdWNjZXNzID0gZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgZG9jID0gZS50YXJnZXQucmVzdWx0O1xuICAgIHZhciByZXYgPSBkb2MucmV2c1tvcHRzLnJldiB8fCBkb2MucmV2XS5kYXRhO1xuICAgIHZhciBkaWdlc3QgPSByZXYuX2F0dGFjaG1lbnRzW2F0dGFjaElkXS5kaWdlc3Q7XG4gICAgYXR0YWNobWVudCA9IGRvYy5hdHRhY2htZW50c1tkaWdlc3RdLmRhdGE7XG4gIH07XG5cbiAgdHhuLnR4bi5vbmNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgIHBhcnNlQXR0YWNobWVudChhdHRhY2htZW50LCBvcHRzLCBjYik7XG4gIH07XG5cbiAgdHhuLnR4bi5vbmFib3J0ID0gY2I7XG59XG5cbmZ1bmN0aW9uIGJ1bGtEb2NzIChhcGksIHJlcSwgb3B0cywgbWV0YWRhdGEsIGRiT3B0cywgaWRiQ2hhbmdlcywgY2FsbGJhY2spIHtcblxuICB2YXIgdHhuO1xuXG4gIC8vIFRPRE86IEkgd291bGQgcHJlZmVyIHRvIGdldCByaWQgb2YgdGhlc2UgZ2xvYmFsc1xuICB2YXIgZXJyb3I7XG4gIHZhciByZXN1bHRzID0gW107XG4gIHZhciBkb2NzID0gW107XG4gIHZhciBsYXN0V3JpdGVJbmRleDtcblxuICB2YXIgcmV2c0xpbWl0ID0gZGJPcHRzLnJldnNfbGltaXQgfHwgMTAwMDtcbiAgdmFyIHJld3JpdGVFbmFibGVkID0gZGJPcHRzLm5hbWUuaW5kZXhPZihcIi1tcnZpZXctXCIpID09PSAtMTtcbiAgY29uc3QgYXV0b0NvbXBhY3Rpb24gPSBkYk9wdHMuYXV0b19jb21wYWN0aW9uO1xuXG4gIC8vIFdlIG9ubHkgbmVlZCB0byB0cmFjayAxIHJldmlzaW9uIGZvciBsb2NhbCBkb2N1bWVudHNcbiAgZnVuY3Rpb24gZG9jc1JldnNMaW1pdChkb2MpIHtcbiAgICByZXR1cm4gL15fbG9jYWwvLnRlc3QoZG9jLmlkKSA/IDEgOiByZXZzTGltaXQ7XG4gIH1cblxuICBmdW5jdGlvbiByb290SXNNaXNzaW5nKGRvYykge1xuICAgIHJldHVybiBkb2MucmV2X3RyZWVbMF0uaWRzWzFdLnN0YXR1cyA9PT0gJ21pc3NpbmcnO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VCYXNlNjQoZGF0YSkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXRvYihkYXRhKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBlcnJvcjogY3JlYXRlRXJyb3IoQkFEX0FSRywgJ0F0dGFjaG1lbnQgaXMgbm90IGEgdmFsaWQgYmFzZTY0IHN0cmluZycpXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIC8vIFJlYWRzIHRoZSBvcmlnaW5hbCBkb2MgZnJvbSB0aGUgc3RvcmUgaWYgYXZhaWxhYmxlXG4gIC8vIEFzIGluIGFsbERvY3Mgd2l0aCBrZXlzIG9wdGlvbiB1c2luZyBtdWx0aXBsZSBnZXQgY2FsbHMgaXMgdGhlIGZhc3Rlc3Qgd2F5XG4gIGZ1bmN0aW9uIGZldGNoRXhpc3RpbmdEb2NzKHR4biwgZG9jcykge1xuICAgIHZhciBmZXRjaGVkID0gMDtcbiAgICB2YXIgb2xkRG9jcyA9IHt9O1xuXG4gICAgZnVuY3Rpb24gcmVhZERvbmUoZSkge1xuICAgICAgaWYgKGUudGFyZ2V0LnJlc3VsdCkge1xuICAgICAgICBvbGREb2NzW2UudGFyZ2V0LnJlc3VsdC5pZF0gPSBlLnRhcmdldC5yZXN1bHQ7XG4gICAgICB9XG4gICAgICBpZiAoKytmZXRjaGVkID09PSBkb2NzLmxlbmd0aCkge1xuICAgICAgICBwcm9jZXNzRG9jcyh0eG4sIGRvY3MsIG9sZERvY3MpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGRvY3MuZm9yRWFjaChmdW5jdGlvbiAoZG9jKSB7XG4gICAgICB0eG4ub2JqZWN0U3RvcmUoRE9DX1NUT1JFKS5nZXQoZG9jLmlkKS5vbnN1Y2Nlc3MgPSByZWFkRG9uZTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJldkhhc0F0dGFjaG1lbnQoZG9jLCByZXYsIGRpZ2VzdCkge1xuICAgIHJldHVybiBkb2MucmV2c1tyZXZdICYmXG4gICAgICBkb2MucmV2c1tyZXZdLmRhdGEuX2F0dGFjaG1lbnRzICYmXG4gICAgICBPYmplY3QudmFsdWVzKGRvYy5yZXZzW3Jldl0uZGF0YS5fYXR0YWNobWVudHMpLmZpbmQoZnVuY3Rpb24gKGF0dCkge1xuICAgICAgICByZXR1cm4gYXR0LmRpZ2VzdCA9PT0gZGlnZXN0O1xuICAgICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBwcm9jZXNzRG9jcyh0eG4sIGRvY3MsIG9sZERvY3MpIHtcblxuICAgIGRvY3MuZm9yRWFjaChmdW5jdGlvbiAoZG9jLCBpKSB7XG4gICAgICB2YXIgbmV3RG9jO1xuXG4gICAgICAvLyBUaGUgZmlyc3QgZG9jdW1lbnQgd3JpdGUgY2Fubm90IGJlIGEgZGVsZXRpb25cbiAgICAgIGlmICgnd2FzX2RlbGV0ZScgaW4gb3B0cyAmJiAhKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvbGREb2NzLCBkb2MuaWQpKSkge1xuICAgICAgICBuZXdEb2MgPSBjcmVhdGVFcnJvcihNSVNTSU5HX0RPQywgJ2RlbGV0ZWQnKTtcblxuICAgICAgLy8gVGhlIGZpcnN0IHdyaXRlIG9mIGEgZG9jdW1lbnQgY2Fubm90IHNwZWNpZnkgYSByZXZpc2lvblxuICAgICAgfSBlbHNlIGlmIChvcHRzLm5ld19lZGl0cyAmJlxuICAgICAgICAgICAgICAgICAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9sZERvY3MsIGRvYy5pZCkgJiZcbiAgICAgICAgICAgICAgICAgcm9vdElzTWlzc2luZyhkb2MpKSB7XG4gICAgICAgIG5ld0RvYyA9IGNyZWF0ZUVycm9yKFJFVl9DT05GTElDVCk7XG5cbiAgICAgIC8vIFVwZGF0ZSB0aGUgZXhpc3RpbmcgZG9jdW1lbnRcbiAgICAgIH0gZWxzZSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9sZERvY3MsIGRvYy5pZCkpIHtcbiAgICAgICAgbmV3RG9jID0gdXBkYXRlKHR4biwgZG9jLCBvbGREb2NzW2RvYy5pZF0pO1xuICAgICAgICAvLyBUaGUgdXBkYXRlIGNhbiBiZSByZWplY3RlZCBpZiBpdCBpcyBhbiB1cGRhdGUgdG8gYW4gZXhpc3RpbmdcbiAgICAgICAgLy8gcmV2aXNpb24sIGlmIHNvIHNraXAgaXRcbiAgICAgICAgaWYgKG5ld0RvYyA9PSBmYWxzZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAvLyBOZXcgZG9jdW1lbnRcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEVuc3VyZSBuZXcgZG9jdW1lbnRzIGFyZSBhbHNvIHN0ZW1tZWRcbiAgICAgICAgdmFyIG1lcmdlZCA9IG1lcmdlKFtdLCBkb2MucmV2X3RyZWVbMF0sIGRvY3NSZXZzTGltaXQoZG9jKSk7XG4gICAgICAgIGRvYy5yZXZfdHJlZSA9IG1lcmdlZC50cmVlO1xuICAgICAgICBkb2Muc3RlbW1lZFJldnMgPSBtZXJnZWQuc3RlbW1lZFJldnM7XG4gICAgICAgIG5ld0RvYyA9IGRvYztcbiAgICAgICAgbmV3RG9jLmlzTmV3RG9jID0gdHJ1ZTtcbiAgICAgICAgbmV3RG9jLndhc0RlbGV0ZWQgPSBkb2MucmV2c1tkb2MucmV2XS5kZWxldGVkID8gMSA6IDA7XG4gICAgICB9XG5cbiAgICAgIGlmIChuZXdEb2MuZXJyb3IpIHtcbiAgICAgICAgcmVzdWx0c1tpXSA9IG5ld0RvYztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9sZERvY3NbbmV3RG9jLmlkXSA9IG5ld0RvYztcbiAgICAgICAgbGFzdFdyaXRlSW5kZXggPSBpO1xuICAgICAgICB3cml0ZSh0eG4sIG5ld0RvYywgaSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvLyBDb252ZXJ0cyBmcm9tIHRoZSBmb3JtYXQgcmV0dXJuZWQgYnkgcGFyc2VEb2MgaW50byB0aGUgbmV3IGZvcm1hdFxuICAvLyB3ZSB1c2UgdG8gc3RvcmVcbiAgZnVuY3Rpb24gY29udmVydERvY0Zvcm1hdChkb2MpIHtcblxuICAgIHZhciBuZXdEb2MgPSB7XG4gICAgICBpZDogZG9jLm1ldGFkYXRhLmlkLFxuICAgICAgcmV2OiBkb2MubWV0YWRhdGEucmV2LFxuICAgICAgcmV2X3RyZWU6IGRvYy5tZXRhZGF0YS5yZXZfdHJlZSxcbiAgICAgIHJldnM6IGRvYy5tZXRhZGF0YS5yZXZzIHx8IHt9XG4gICAgfTtcblxuICAgIG5ld0RvYy5yZXZzW25ld0RvYy5yZXZdID0ge1xuICAgICAgZGF0YTogZG9jLmRhdGEsXG4gICAgICBkZWxldGVkOiBkb2MubWV0YWRhdGEuZGVsZXRlZFxuICAgIH07XG5cbiAgICByZXR1cm4gbmV3RG9jO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlKHR4biwgZG9jLCBvbGREb2MpIHtcblxuICAgIC8vIElnbm9yZSB1cGRhdGVzIHRvIGV4aXN0aW5nIHJldmlzaW9uc1xuICAgIGlmICgoZG9jLnJldiBpbiBvbGREb2MucmV2cykgJiYgIW9wdHMubmV3X2VkaXRzKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGlzUm9vdCA9IC9eMS0vLnRlc3QoZG9jLnJldik7XG5cbiAgICAvLyBSZWF0dGFjaCBmaXJzdCB3cml0ZXMgYWZ0ZXIgYSBkZWxldGlvbiB0byBsYXN0IGRlbGV0ZWQgdHJlZVxuICAgIGlmIChvbGREb2MuZGVsZXRlZCAmJiAhZG9jLmRlbGV0ZWQgJiYgb3B0cy5uZXdfZWRpdHMgJiYgaXNSb290KSB7XG4gICAgICB2YXIgdG1wID0gZG9jLnJldnNbZG9jLnJldl0uZGF0YTtcbiAgICAgIHRtcC5fcmV2ID0gb2xkRG9jLnJldjtcbiAgICAgIHRtcC5faWQgPSBvbGREb2MuaWQ7XG4gICAgICBkb2MgPSBjb252ZXJ0RG9jRm9ybWF0KHBhcnNlRG9jKHRtcCwgb3B0cy5uZXdfZWRpdHMsIGRiT3B0cykpO1xuICAgIH1cblxuICAgIHZhciBtZXJnZWQgPSBtZXJnZShvbGREb2MucmV2X3RyZWUsIGRvYy5yZXZfdHJlZVswXSwgZG9jc1JldnNMaW1pdChkb2MpKTtcbiAgICBkb2Muc3RlbW1lZFJldnMgPSBtZXJnZWQuc3RlbW1lZFJldnM7XG4gICAgZG9jLnJldl90cmVlID0gbWVyZ2VkLnRyZWU7XG5cbiAgICAvLyBNZXJnZSB0aGUgb2xkIGFuZCBuZXcgcmV2IGRhdGFcbiAgICB2YXIgcmV2cyA9IG9sZERvYy5yZXZzO1xuICAgIHJldnNbZG9jLnJldl0gPSBkb2MucmV2c1tkb2MucmV2XTtcbiAgICBkb2MucmV2cyA9IHJldnM7XG5cbiAgICBkb2MuYXR0YWNobWVudHMgPSBvbGREb2MuYXR0YWNobWVudHM7XG5cbiAgICB2YXIgaW5Db25mbGljdCA9IG9wdHMubmV3X2VkaXRzICYmICgoKG9sZERvYy5kZWxldGVkICYmIGRvYy5kZWxldGVkKSB8fFxuICAgICAgICghb2xkRG9jLmRlbGV0ZWQgJiYgbWVyZ2VkLmNvbmZsaWN0cyAhPT0gJ25ld19sZWFmJykgfHxcbiAgICAgICAob2xkRG9jLmRlbGV0ZWQgJiYgIWRvYy5kZWxldGVkICYmIG1lcmdlZC5jb25mbGljdHMgPT09ICduZXdfYnJhbmNoJykgfHxcbiAgICAgICAob2xkRG9jLnJldiA9PT0gZG9jLnJldikpKTtcblxuICAgIGlmIChpbkNvbmZsaWN0KSB7XG4gICAgICByZXR1cm4gY3JlYXRlRXJyb3IoUkVWX0NPTkZMSUNUKTtcbiAgICB9XG5cbiAgICBkb2Mud2FzRGVsZXRlZCA9IG9sZERvYy5kZWxldGVkO1xuXG4gICAgcmV0dXJuIGRvYztcbiAgfVxuXG4gIGZ1bmN0aW9uIHdyaXRlKHR4biwgZG9jLCBpKSB7XG5cbiAgICAvLyBXZSBjb3B5IHRoZSBkYXRhIGZyb20gdGhlIHdpbm5pbmcgcmV2aXNpb24gaW50byB0aGUgcm9vdFxuICAgIC8vIG9mIHRoZSBkb2N1bWVudCBzbyB0aGF0IGl0IGNhbiBiZSBpbmRleGVkXG4gICAgdmFyIHdpbm5pbmdSZXYkJDEgPSB3aW5uaW5nUmV2KGRvYyk7XG4gICAgLy8gcmV2IG9mIG5ldyBkb2MgZm9yIGF0dGFjaG1lbnRzIGFuZCB0byByZXR1cm4gaXRcbiAgICB2YXIgd3JpdHRlblJldiA9IGRvYy5yZXY7XG4gICAgdmFyIGlzTG9jYWwgPSAvXl9sb2NhbC8udGVzdChkb2MuaWQpO1xuXG4gICAgdmFyIHRoZURvYyA9IGRvYy5yZXZzW3dpbm5pbmdSZXYkJDFdLmRhdGE7XG5cbiAgICBjb25zdCBpc05ld0RvYyA9IGRvYy5pc05ld0RvYztcblxuICAgIGlmIChyZXdyaXRlRW5hYmxlZCkge1xuICAgICAgLy8gZG9jLmRhdGEgaXMgd2hhdCB3ZSBpbmRleCwgc28gd2UgbmVlZCB0byBjbG9uZSBhbmQgcmV3cml0ZSBpdCwgYW5kIGNsZWFuXG4gICAgICAvLyBpdCB1cCBmb3IgaW5kZXhhYmlsaXR5XG4gICAgICB2YXIgcmVzdWx0ID0gcmV3cml0ZSh0aGVEb2MpO1xuICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICBkb2MuZGF0YSA9IHJlc3VsdDtcbiAgICAgICAgZGVsZXRlIGRvYy5kYXRhLl9hdHRhY2htZW50cztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRvYy5kYXRhID0gdGhlRG9jO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBkb2MuZGF0YSA9IHRoZURvYztcbiAgICB9XG5cbiAgICBkb2MucmV2ID0gd2lubmluZ1JldiQkMTtcbiAgICAvLyAuZGVsZXRlZCBuZWVkcyB0byBiZSBhbiBpbnQgZm9yIGluZGV4aW5nXG4gICAgZG9jLmRlbGV0ZWQgPSBkb2MucmV2c1t3aW5uaW5nUmV2JCQxXS5kZWxldGVkID8gMSA6IDA7XG5cbiAgICAvLyBCdW1wIHRoZSBzZXEgZm9yIGV2ZXJ5IG5ldyAobm9uIGxvY2FsKSByZXZpc2lvbiB3cml0dGVuXG4gICAgLy8gVE9ETzogaW5kZXggZXhwZWN0cyBhIHVuaXF1ZSBzZXEsIG5vdCBzdXJlIGlmIGlnbm9yaW5nIGxvY2FsIHdpbGxcbiAgICAvLyB3b3JrXG4gICAgaWYgKCFpc0xvY2FsKSB7XG4gICAgICBkb2Muc2VxID0gKyttZXRhZGF0YS5zZXE7XG5cbiAgICAgIHZhciBkZWx0YSA9IDA7XG4gICAgICAvLyBJZiBpdHMgYSBuZXcgZG9jdW1lbnQsIHdlIHdvbnQgZGVjcmVtZW50IGlmIGRlbGV0ZWRcbiAgICAgIGlmIChkb2MuaXNOZXdEb2MpIHtcbiAgICAgICAgZGVsdGEgPSBkb2MuZGVsZXRlZCA/IDAgOiAxO1xuICAgICAgfSBlbHNlIGlmIChkb2Mud2FzRGVsZXRlZCAhPT0gZG9jLmRlbGV0ZWQpIHtcbiAgICAgICAgZGVsdGEgPSBkb2MuZGVsZXRlZCA/IC0xIDogMTtcbiAgICAgIH1cbiAgICAgIG1ldGFkYXRhLmRvY19jb3VudCArPSBkZWx0YTtcbiAgICB9XG4gICAgZGVsZXRlIGRvYy5pc05ld0RvYztcbiAgICBkZWxldGUgZG9jLndhc0RlbGV0ZWQ7XG5cbiAgICAvLyBJZiB0aGVyZSBoYXZlIGJlZW4gcmV2aXNpb25zIHN0ZW1tZWQgd2hlbiBtZXJnaW5nIHRyZWVzLFxuICAgIC8vIGRlbGV0ZSB0aGVpciBkYXRhXG4gICAgbGV0IHJldnNUb0RlbGV0ZSA9IGRvYy5zdGVtbWVkUmV2cyB8fCBbXTtcblxuICAgIGlmIChhdXRvQ29tcGFjdGlvbiAmJiAhaXNOZXdEb2MpIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGNvbXBhY3RUcmVlKGRvYyk7XG4gICAgICBpZiAocmVzdWx0Lmxlbmd0aCkge1xuICAgICAgICByZXZzVG9EZWxldGUgPSByZXZzVG9EZWxldGUuY29uY2F0KHJlc3VsdCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHJldnNUb0RlbGV0ZS5sZW5ndGgpIHtcbiAgICAgIHJldnNUb0RlbGV0ZS5mb3JFYWNoKGZ1bmN0aW9uIChyZXYpIHsgZGVsZXRlIGRvYy5yZXZzW3Jldl07IH0pO1xuICAgIH1cblxuICAgIGRlbGV0ZSBkb2Muc3RlbW1lZFJldnM7XG5cbiAgICBpZiAoISgnYXR0YWNobWVudHMnIGluIGRvYykpIHtcbiAgICAgIGRvYy5hdHRhY2htZW50cyA9IHt9O1xuICAgIH1cblxuICAgIGlmICh0aGVEb2MuX2F0dGFjaG1lbnRzKSB7XG4gICAgICBmb3IgKHZhciBrIGluIHRoZURvYy5fYXR0YWNobWVudHMpIHtcbiAgICAgICAgdmFyIGF0dGFjaG1lbnQgPSB0aGVEb2MuX2F0dGFjaG1lbnRzW2tdO1xuICAgICAgICBpZiAoYXR0YWNobWVudC5zdHViKSB7XG4gICAgICAgICAgaWYgKCEoYXR0YWNobWVudC5kaWdlc3QgaW4gZG9jLmF0dGFjaG1lbnRzKSkge1xuICAgICAgICAgICAgZXJyb3IgPSBjcmVhdGVFcnJvcihNSVNTSU5HX1NUVUIpO1xuICAgICAgICAgICAgLy8gVE9ETzogTm90IHN1cmUgaG93IHNhZmUgdGhpcyBtYW51YWwgYWJvcnQgaXMsIHNlZWluZ1xuICAgICAgICAgICAgLy8gY29uc29sZSBpc3N1ZXNcbiAgICAgICAgICAgIHR4bi5hYm9ydCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChyZXZIYXNBdHRhY2htZW50KGRvYywgd3JpdHRlblJldiwgYXR0YWNobWVudC5kaWdlc3QpKSB7XG4gICAgICAgICAgICBkb2MuYXR0YWNobWVudHNbYXR0YWNobWVudC5kaWdlc3RdLnJldnNbd3JpdHRlblJldl0gPSB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgZG9jLmF0dGFjaG1lbnRzW2F0dGFjaG1lbnQuZGlnZXN0XSA9IGF0dGFjaG1lbnQ7XG4gICAgICAgICAgZG9jLmF0dGFjaG1lbnRzW2F0dGFjaG1lbnQuZGlnZXN0XS5yZXZzID0ge307XG4gICAgICAgICAgZG9jLmF0dGFjaG1lbnRzW2F0dGFjaG1lbnQuZGlnZXN0XS5yZXZzW3dyaXR0ZW5SZXZdID0gdHJ1ZTtcblxuICAgICAgICAgIHRoZURvYy5fYXR0YWNobWVudHNba10gPSB7XG4gICAgICAgICAgICBzdHViOiB0cnVlLFxuICAgICAgICAgICAgZGlnZXN0OiBhdHRhY2htZW50LmRpZ2VzdCxcbiAgICAgICAgICAgIGNvbnRlbnRfdHlwZTogYXR0YWNobWVudC5jb250ZW50X3R5cGUsXG4gICAgICAgICAgICBsZW5ndGg6IGF0dGFjaG1lbnQubGVuZ3RoLFxuICAgICAgICAgICAgcmV2cG9zOiBwYXJzZUludCh3cml0dGVuUmV2LCAxMClcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gTG9jYWwgZG9jdW1lbnRzIGhhdmUgZGlmZmVyZW50IHJldmlzaW9uIGhhbmRsaW5nXG4gICAgaWYgKGlzTG9jYWwgJiYgZG9jLmRlbGV0ZWQpIHtcbiAgICAgIHR4bi5vYmplY3RTdG9yZShET0NfU1RPUkUpLmRlbGV0ZShkb2MuaWQpLm9uc3VjY2VzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmVzdWx0c1tpXSA9IHtcbiAgICAgICAgICBvazogdHJ1ZSxcbiAgICAgICAgICBpZDogZG9jLmlkLFxuICAgICAgICAgIHJldjogJzAtMCdcbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgICB1cGRhdGVTZXEoaSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdHhuLm9iamVjdFN0b3JlKERPQ19TVE9SRSkucHV0KGRvYykub25zdWNjZXNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmVzdWx0c1tpXSA9IHtcbiAgICAgICAgb2s6IHRydWUsXG4gICAgICAgIGlkOiBkb2MuaWQsXG4gICAgICAgIHJldjogd3JpdHRlblJldlxuICAgICAgfTtcbiAgICAgIHVwZGF0ZVNlcShpKTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlU2VxKGkpIHtcbiAgICBpZiAoaSA9PT0gbGFzdFdyaXRlSW5kZXgpIHtcbiAgICAgIHR4bi5vYmplY3RTdG9yZShNRVRBX1NUT1JFKS5wdXQobWV0YWRhdGEpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHByZVByb2Nlc3NBdHRhY2htZW50KGF0dGFjaG1lbnQpIHtcbiAgICBpZiAoYXR0YWNobWVudC5zdHViKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGF0dGFjaG1lbnQpO1xuICAgIH1cblxuICAgIHZhciBiaW5EYXRhO1xuICAgIGlmICh0eXBlb2YgYXR0YWNobWVudC5kYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgYmluRGF0YSA9IHBhcnNlQmFzZTY0KGF0dGFjaG1lbnQuZGF0YSk7XG4gICAgICBpZiAoYmluRGF0YS5lcnJvcikge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoYmluRGF0YS5lcnJvcik7XG4gICAgICB9XG4gICAgICBhdHRhY2htZW50LmRhdGEgPSBiaW5hcnlTdHJpbmdUb0Jsb2JPckJ1ZmZlcihiaW5EYXRhLCBhdHRhY2htZW50LmNvbnRlbnRfdHlwZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJpbkRhdGEgPSBhdHRhY2htZW50LmRhdGE7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICBiaW5hcnlNZDUoYmluRGF0YSwgZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICBhdHRhY2htZW50LmRpZ2VzdCA9ICdtZDUtJyArIHJlc3VsdDtcbiAgICAgICAgYXR0YWNobWVudC5sZW5ndGggPSBiaW5EYXRhLnNpemUgfHwgYmluRGF0YS5sZW5ndGggfHwgMDtcbiAgICAgICAgcmVzb2x2ZShhdHRhY2htZW50KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJlUHJvY2Vzc0F0dGFjaG1lbnRzKCkge1xuICAgIHZhciBwcm9taXNlcyA9IGRvY3MubWFwKGZ1bmN0aW9uIChkb2MpIHtcbiAgICAgIHZhciBkYXRhID0gZG9jLnJldnNbZG9jLnJldl0uZGF0YTtcbiAgICAgIGlmICghZGF0YS5fYXR0YWNobWVudHMpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShkYXRhKTtcbiAgICAgIH1cbiAgICAgIHZhciBhdHRhY2htZW50cyA9IE9iamVjdC5rZXlzKGRhdGEuX2F0dGFjaG1lbnRzKS5tYXAoZnVuY3Rpb24gKGspIHtcbiAgICAgICAgZGF0YS5fYXR0YWNobWVudHNba10ubmFtZSA9IGs7XG4gICAgICAgIHJldHVybiBwcmVQcm9jZXNzQXR0YWNobWVudChkYXRhLl9hdHRhY2htZW50c1trXSk7XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIFByb21pc2UuYWxsKGF0dGFjaG1lbnRzKS50aGVuKGZ1bmN0aW9uIChuZXdBdHRhY2htZW50cykge1xuICAgICAgICB2YXIgcHJvY2Vzc2VkID0ge307XG4gICAgICAgIG5ld0F0dGFjaG1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGF0dGFjaG1lbnQpIHtcbiAgICAgICAgICBwcm9jZXNzZWRbYXR0YWNobWVudC5uYW1lXSA9IGF0dGFjaG1lbnQ7XG4gICAgICAgICAgZGVsZXRlIGF0dGFjaG1lbnQubmFtZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGRhdGEuX2F0dGFjaG1lbnRzID0gcHJvY2Vzc2VkO1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gcmVxLmRvY3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICB2YXIgcmVzdWx0O1xuICAgIC8vIFRPRE86IFdlIHNob3VsZCBnZXQgcmlkIG9mIHRocm93aW5nIGZvciBpbnZhbGlkIGRvY3MsIGFsc28gbm90IHN1cmVcbiAgICAvLyB3aHkgdGhpcyBpcyBuZWVkZWQgaW4gaWRiLW5leHQgYW5kIG5vdCBpZGJcbiAgICB0cnkge1xuICAgICAgcmVzdWx0ID0gcGFyc2VEb2MocmVxLmRvY3NbaV0sIG9wdHMubmV3X2VkaXRzLCBkYk9wdHMpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmVzdWx0ID0gZXJyO1xuICAgIH1cbiAgICBpZiAocmVzdWx0LmVycm9yKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2socmVzdWx0KTtcbiAgICB9XG5cbiAgICAvLyBJZGVhbGx5IHBhcnNlRG9jIHdvdWxkIHJldHVybiBkYXRhIGluIHRoaXMgZm9ybWF0LCBidXQgaXQgaXMgY3VycmVudGx5XG4gICAgLy8gc2hhcmVkIHNvIHdlIG5lZWQgdG8gY29udmVydFxuICAgIGRvY3MucHVzaChjb252ZXJ0RG9jRm9ybWF0KHJlc3VsdCkpO1xuICB9XG5cbiAgcHJlUHJvY2Vzc0F0dGFjaG1lbnRzKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgYXBpLl9vcGVuVHJhbnNhY3Rpb25TYWZlbHkoW0RPQ19TVE9SRSwgTUVUQV9TVE9SRV0sICdyZWFkd3JpdGUnLCBmdW5jdGlvbiAoZXJyLCBfdHhuKSB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgfVxuXG4gICAgICB0eG4gPSBfdHhuO1xuXG4gICAgICB0eG4ub25hYm9ydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY2FsbGJhY2soZXJyb3IgfHwgY3JlYXRlRXJyb3IoVU5LTk9XTl9FUlJPUiwgJ3RyYW5zYWN0aW9uIHdhcyBhYm9ydGVkJykpO1xuICAgICAgfTtcbiAgICAgIHR4bi5vbnRpbWVvdXQgPSBpZGJFcnJvcihjYWxsYmFjayk7XG5cbiAgICAgIHR4bi5vbmNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZGJDaGFuZ2VzLm5vdGlmeShkYk9wdHMubmFtZSk7XG4gICAgICAgIGNhbGxiYWNrKG51bGwsIHJlc3VsdHMpO1xuICAgICAgfTtcblxuICAgICAgLy8gV2Ugd291bGQgbGlrZSB0byB1c2UgcHJvbWlzZXMgaGVyZSwgYnV0IGlkYiBzdWNrc1xuICAgICAgZmV0Y2hFeGlzdGluZ0RvY3ModHhuLCBkb2NzKTtcbiAgICB9KTtcbiAgfSkuY2F0Y2goZnVuY3Rpb24gKGVycikge1xuICAgIGNhbGxiYWNrKGVycik7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBhbGxEb2NzS2V5cyhrZXlzLCBkb2NTdG9yZSwgYWxsRG9jc0lubmVyKSB7XG4gIC8vIEl0J3Mgbm90IGd1YXJhbnRlZCB0byBiZSByZXR1cm5lZCBpbiByaWdodCBvcmRlclxuICB2YXIgdmFsdWVzQmF0Y2ggPSBuZXcgQXJyYXkoa2V5cy5sZW5ndGgpO1xuICB2YXIgY291bnQgPSAwO1xuICBrZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSwgaW5kZXgpIHtcbiAgICBkb2NTdG9yZS5nZXQoa2V5KS5vbnN1Y2Nlc3MgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIGlmIChldmVudC50YXJnZXQucmVzdWx0KSB7XG4gICAgICB2YWx1ZXNCYXRjaFtpbmRleF0gPSBldmVudC50YXJnZXQucmVzdWx0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWVzQmF0Y2hbaW5kZXhdID0ge2tleToga2V5LCBlcnJvcjogJ25vdF9mb3VuZCd9O1xuICAgICAgfVxuICAgICAgY291bnQrKztcbiAgICAgIGlmIChjb3VudCA9PT0ga2V5cy5sZW5ndGgpIHtcbiAgICAgICAgdmFsdWVzQmF0Y2guZm9yRWFjaChmdW5jdGlvbiAoZG9jKSB7XG4gICAgICAgICAgICBhbGxEb2NzSW5uZXIoZG9jKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUtleVJhbmdlKHN0YXJ0LCBlbmQsIGluY2x1c2l2ZUVuZCwga2V5LCBkZXNjZW5kaW5nKSB7XG4gIHRyeSB7XG4gICAgaWYgKHN0YXJ0ICYmIGVuZCkge1xuICAgICAgaWYgKGRlc2NlbmRpbmcpIHtcbiAgICAgICAgcmV0dXJuIElEQktleVJhbmdlLmJvdW5kKGVuZCwgc3RhcnQsICFpbmNsdXNpdmVFbmQsIGZhbHNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBJREJLZXlSYW5nZS5ib3VuZChzdGFydCwgZW5kLCBmYWxzZSwgIWluY2x1c2l2ZUVuZCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChzdGFydCkge1xuICAgICAgaWYgKGRlc2NlbmRpbmcpIHtcbiAgICAgICAgcmV0dXJuIElEQktleVJhbmdlLnVwcGVyQm91bmQoc3RhcnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIElEQktleVJhbmdlLmxvd2VyQm91bmQoc3RhcnQpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZW5kKSB7XG4gICAgICBpZiAoZGVzY2VuZGluZykge1xuICAgICAgICByZXR1cm4gSURCS2V5UmFuZ2UubG93ZXJCb3VuZChlbmQsICFpbmNsdXNpdmVFbmQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIElEQktleVJhbmdlLnVwcGVyQm91bmQoZW5kLCAhaW5jbHVzaXZlRW5kKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGtleSkge1xuICAgICAgcmV0dXJuIElEQktleVJhbmdlLm9ubHkoa2V5KTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4ge2Vycm9yOiBlfTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gaGFuZGxlS2V5UmFuZ2VFcnJvcihvcHRzLCBtZXRhZGF0YSwgZXJyLCBjYWxsYmFjaykge1xuICBpZiAoZXJyLm5hbWUgPT09IFwiRGF0YUVycm9yXCIgJiYgZXJyLmNvZGUgPT09IDApIHtcbiAgICAvLyBkYXRhIGVycm9yLCBzdGFydCBpcyBsZXNzIHRoYW4gZW5kXG4gICAgdmFyIHJldHVyblZhbCA9IHtcbiAgICAgIHRvdGFsX3Jvd3M6IG1ldGFkYXRhLmRvY19jb3VudCxcbiAgICAgIG9mZnNldDogb3B0cy5za2lwLFxuICAgICAgcm93czogW11cbiAgICB9O1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChvcHRzLnVwZGF0ZV9zZXEpIHtcbiAgICAgIHJldHVyblZhbC51cGRhdGVfc2VxID0gbWV0YWRhdGEuc2VxO1xuICAgIH1cbiAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgcmV0dXJuVmFsKTtcbiAgfVxuICBjYWxsYmFjayhjcmVhdGVFcnJvcihJREJfRVJST1IsIGVyci5uYW1lLCBlcnIubWVzc2FnZSkpO1xufVxuXG5mdW5jdGlvbiBhbGxEb2NzICh0eG4sIG1ldGFkYXRhLCBvcHRzLCBjYWxsYmFjaykge1xuICBpZiAodHhuLmVycm9yKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrKHR4bi5lcnJvcik7XG4gIH1cblxuICAvLyBUT0RPOiBXZWlyZCBoYWNrLCBJIGRvbnQgbGlrZSBpdFxuICBpZiAob3B0cy5saW1pdCA9PT0gMCkge1xuICAgIHZhciByZXR1cm5WYWwgPSB7XG4gICAgICB0b3RhbF9yb3dzOiBtZXRhZGF0YS5kb2NfY291bnQsXG4gICAgICBvZmZzZXQ6IG9wdHMuc2tpcCxcbiAgICAgIHJvd3M6IFtdXG4gICAgfTtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChvcHRzLnVwZGF0ZV9zZXEpIHtcbiAgICAgIHJldHVyblZhbC51cGRhdGVfc2VxID0gbWV0YWRhdGEuc2VxO1xuICAgIH1cbiAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgcmV0dXJuVmFsKTtcbiAgfVxuXG4gIHZhciByZXN1bHRzID0gW107XG4gIHZhciBwcm9jZXNzaW5nID0gW107XG5cbiAgdmFyIHN0YXJ0ID0gJ3N0YXJ0a2V5JyBpbiBvcHRzID8gb3B0cy5zdGFydGtleSA6IGZhbHNlO1xuICB2YXIgZW5kID0gJ2VuZGtleScgaW4gb3B0cyA/IG9wdHMuZW5ka2V5IDogZmFsc2U7XG4gIHZhciBrZXkgPSAna2V5JyBpbiBvcHRzID8gb3B0cy5rZXkgOiBmYWxzZTtcbiAgdmFyIGtleXMgPSAna2V5cycgaW4gb3B0cyA/IG9wdHMua2V5cyA6IGZhbHNlO1xuICB2YXIgc2tpcCA9IG9wdHMuc2tpcCB8fCAwO1xuICB2YXIgbGltaXQgPSB0eXBlb2Ygb3B0cy5saW1pdCA9PT0gJ251bWJlcicgPyBvcHRzLmxpbWl0IDogLTE7XG4gIHZhciBpbmNsdXNpdmVFbmQgPSBvcHRzLmluY2x1c2l2ZV9lbmQgIT09IGZhbHNlO1xuICB2YXIgZGVzY2VuZGluZyA9ICdkZXNjZW5kaW5nJyBpbiBvcHRzICYmIG9wdHMuZGVzY2VuZGluZyA/ICdwcmV2JyA6IG51bGw7XG5cbiAgdmFyIGtleVJhbmdlO1xuICBpZiAoIWtleXMpIHtcbiAgICBrZXlSYW5nZSA9IGNyZWF0ZUtleVJhbmdlKHN0YXJ0LCBlbmQsIGluY2x1c2l2ZUVuZCwga2V5LCBkZXNjZW5kaW5nKTtcbiAgICBpZiAoa2V5UmFuZ2UgJiYga2V5UmFuZ2UuZXJyb3IpIHtcbiAgICAgIHJldHVybiBoYW5kbGVLZXlSYW5nZUVycm9yKG9wdHMsIG1ldGFkYXRhLCBrZXlSYW5nZS5lcnJvciwgY2FsbGJhY2spO1xuICAgIH1cbiAgfVxuXG4gIHZhciBkb2NTdG9yZSA9IHR4bi50eG4ub2JqZWN0U3RvcmUoRE9DX1NUT1JFKTtcblxuICB0eG4udHhuLm9uY29tcGxldGUgPSBvblR4bkNvbXBsZXRlO1xuXG4gIGlmIChrZXlzKSB7XG4gICAgcmV0dXJuIGFsbERvY3NLZXlzKG9wdHMua2V5cywgZG9jU3RvcmUsIGFsbERvY3NJbm5lcik7XG4gIH1cblxuICBmdW5jdGlvbiBpbmNsdWRlX2RvYyhyb3csIGRvYykge1xuICAgIHZhciBkb2NEYXRhID0gZG9jLnJldnNbZG9jLnJldl0uZGF0YTtcblxuICAgIHJvdy5kb2MgPSBkb2NEYXRhO1xuICAgIHJvdy5kb2MuX2lkID0gZG9jLmlkO1xuICAgIHJvdy5kb2MuX3JldiA9IGRvYy5yZXY7XG4gICAgaWYgKG9wdHMuY29uZmxpY3RzKSB7XG4gICAgICB2YXIgY29uZmxpY3RzID0gY29sbGVjdENvbmZsaWN0cyhkb2MpO1xuICAgICAgaWYgKGNvbmZsaWN0cy5sZW5ndGgpIHtcbiAgICAgICAgcm93LmRvYy5fY29uZmxpY3RzID0gY29uZmxpY3RzO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAob3B0cy5hdHRhY2htZW50cyAmJiBkb2NEYXRhLl9hdHRhY2htZW50cykge1xuICAgICAgZm9yICh2YXIgbmFtZSBpbiBkb2NEYXRhLl9hdHRhY2htZW50cykge1xuICAgICAgICBwcm9jZXNzaW5nLnB1c2gocHJvY2Vzc0F0dGFjaG1lbnQobmFtZSwgZG9jLCByb3cuZG9jLCBvcHRzLmJpbmFyeSkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGFsbERvY3NJbm5lcihkb2MpIHtcbiAgICBpZiAoZG9jLmVycm9yICYmIGtleXMpIHtcbiAgICAgIC8vIGtleSB3YXMgbm90IGZvdW5kIHdpdGggXCJrZXlzXCIgcmVxdWVzdHNcbiAgICAgIHJlc3VsdHMucHVzaChkb2MpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgdmFyIHJvdyA9IHtcbiAgICAgIGlkOiBkb2MuaWQsXG4gICAgICBrZXk6IGRvYy5pZCxcbiAgICAgIHZhbHVlOiB7XG4gICAgICAgIHJldjogZG9jLnJldlxuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgZGVsZXRlZCA9IGRvYy5kZWxldGVkO1xuICAgIGlmIChkZWxldGVkKSB7XG4gICAgICBpZiAoa2V5cykge1xuICAgICAgICByZXN1bHRzLnB1c2gocm93KTtcbiAgICAgICAgcm93LnZhbHVlLmRlbGV0ZWQgPSB0cnVlO1xuICAgICAgICByb3cuZG9jID0gbnVsbDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHNraXAtLSA8PSAwKSB7XG4gICAgICByZXN1bHRzLnB1c2gocm93KTtcbiAgICAgIGlmIChvcHRzLmluY2x1ZGVfZG9jcykge1xuICAgICAgICBpbmNsdWRlX2RvYyhyb3csIGRvYyk7XG4gICAgICB9XG4gICAgICBpZiAoLS1saW1pdCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgZnVuY3Rpb24gb25UeG5Db21wbGV0ZSgpIHtcbiAgICBQcm9taXNlLmFsbChwcm9jZXNzaW5nKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciByZXR1cm5WYWwgPSB7XG4gICAgICAgIHRvdGFsX3Jvd3M6IG1ldGFkYXRhLmRvY19jb3VudCxcbiAgICAgICAgb2Zmc2V0OiAwLFxuICAgICAgICByb3dzOiByZXN1bHRzXG4gICAgICB9O1xuXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChvcHRzLnVwZGF0ZV9zZXEpIHtcbiAgICAgICAgcmV0dXJuVmFsLnVwZGF0ZV9zZXEgPSBtZXRhZGF0YS5zZXE7XG4gICAgICB9XG4gICAgICBjYWxsYmFjayhudWxsLCByZXR1cm5WYWwpO1xuICAgIH0pO1xuICB9XG5cbiAgdmFyIGN1cnNvciA9IGRlc2NlbmRpbmcgP1xuICAgIGRvY1N0b3JlLm9wZW5DdXJzb3Ioa2V5UmFuZ2UsIGRlc2NlbmRpbmcpIDpcbiAgICBkb2NTdG9yZS5vcGVuQ3Vyc29yKGtleVJhbmdlKTtcblxuICBjdXJzb3Iub25zdWNjZXNzID0gZnVuY3Rpb24gKGUpIHtcblxuICAgIHZhciBkb2MgPSBlLnRhcmdldC5yZXN1bHQgJiYgZS50YXJnZXQucmVzdWx0LnZhbHVlO1xuXG4gICAgLy8gSGFwcGVucyBpZiBvcHRzIGRvZXMgbm90IGhhdmUgbGltaXQsXG4gICAgLy8gYmVjYXVzZSBjdXJzb3Igd2lsbCBlbmQgbm9ybWFsbHkgdGhlbixcbiAgICAvLyB3aGVuIGFsbCBkb2NzIGFyZSByZXRyaWV2ZWQuXG4gICAgLy8gV291bGQgbm90IGJlIG5lZWRlZCwgaWYgZ2V0QWxsKCkgb3B0aW1pemF0aW9uIHdhcyB1c2VkIGxpa2UgaW4gIzYwNTlcbiAgICBpZiAoIWRvYykgeyByZXR1cm47IH1cblxuICAgIC8vIFNraXAgbG9jYWwgZG9jc1xuICAgIGlmICgvXl9sb2NhbC8udGVzdChkb2MuaWQpKSB7XG4gICAgICByZXR1cm4gZS50YXJnZXQucmVzdWx0LmNvbnRpbnVlKCk7XG4gICAgfVxuXG4gICAgdmFyIGNvbnRpbnVlQ3Vyc29yID0gYWxsRG9jc0lubmVyKGRvYyk7XG4gICAgaWYgKGNvbnRpbnVlQ3Vyc29yKSB7XG4gICAgICBlLnRhcmdldC5yZXN1bHQuY29udGludWUoKTtcbiAgICB9XG4gIH07XG5cbn1cblxuZnVuY3Rpb24gY2hhbmdlcyAodHhuLCBpZGJDaGFuZ2VzLCBhcGksIGRiT3B0cywgb3B0cykge1xuICBpZiAodHhuLmVycm9yKSB7XG4gICAgcmV0dXJuIG9wdHMuY29tcGxldGUodHhuLmVycm9yKTtcbiAgfVxuXG4gIGlmIChvcHRzLmNvbnRpbnVvdXMpIHtcbiAgICB2YXIgaWQgPSBkYk9wdHMubmFtZSArICc6JyArIHV1aWQoKTtcbiAgICBpZGJDaGFuZ2VzLmFkZExpc3RlbmVyKGRiT3B0cy5uYW1lLCBpZCwgYXBpLCBvcHRzKTtcbiAgICBpZGJDaGFuZ2VzLm5vdGlmeShkYk9wdHMubmFtZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNhbmNlbDogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZGJDaGFuZ2VzLnJlbW92ZUxpc3RlbmVyKGRiT3B0cy5uYW1lLCBpZCk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIHZhciBsaW1pdCA9ICdsaW1pdCcgaW4gb3B0cyA/IG9wdHMubGltaXQgOiAtMTtcbiAgaWYgKGxpbWl0ID09PSAwKSB7XG4gICAgbGltaXQgPSAxO1xuICB9XG5cbiAgdmFyIHN0b3JlID0gdHhuLnR4bi5vYmplY3RTdG9yZShET0NfU1RPUkUpLmluZGV4KCdzZXEnKTtcblxuICB2YXIgZmlsdGVyID0gZmlsdGVyQ2hhbmdlKG9wdHMpO1xuICB2YXIgcmVjZWl2ZWQgPSAwO1xuXG4gIHZhciBsYXN0U2VxID0gb3B0cy5zaW5jZSB8fCAwO1xuICB2YXIgcmVzdWx0cyA9IFtdO1xuXG4gIHZhciBwcm9jZXNzaW5nID0gW107XG5cbiAgZnVuY3Rpb24gb25SZXFTdWNjZXNzKGUpIHtcbiAgICBpZiAoIWUudGFyZ2V0LnJlc3VsdCkgeyByZXR1cm47IH1cbiAgICB2YXIgY3Vyc29yID0gZS50YXJnZXQucmVzdWx0O1xuICAgIHZhciBkb2MgPSBjdXJzb3IudmFsdWU7XG4gICAgLy8gT3ZlcndyaXRlIGRvYy5kYXRhLCB3aGljaCBtYXkgaGF2ZSBiZWVuIHJld3JpdHRlbiAoc2VlIHJld3JpdGUuanMpIHdpdGhcbiAgICAvLyB0aGUgY2xlYW4gdmVyc2lvbiBmb3IgdGhhdCByZXZcbiAgICBkb2MuZGF0YSA9IGRvYy5yZXZzW2RvYy5yZXZdLmRhdGE7XG4gICAgZG9jLmRhdGEuX2lkID0gZG9jLmlkO1xuICAgIGRvYy5kYXRhLl9yZXYgPSBkb2MucmV2O1xuICAgIGlmIChkb2MuZGVsZXRlZCkge1xuICAgICAgZG9jLmRhdGEuX2RlbGV0ZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChvcHRzLmRvY19pZHMgJiYgb3B0cy5kb2NfaWRzLmluZGV4T2YoZG9jLmlkKSA9PT0gLTEpIHtcbiAgICAgIHJldHVybiBjdXJzb3IuY29udGludWUoKTtcbiAgICB9XG5cbiAgICAvLyBXQVJOSU5HOiBleHBlY3RpbmcgcG9zc2libGUgb2xkIGZvcm1hdFxuICAgIHZhciBjaGFuZ2UgPSBvcHRzLnByb2Nlc3NDaGFuZ2UoZG9jLmRhdGEsIGRvYywgb3B0cyk7XG4gICAgY2hhbmdlLnNlcSA9IGRvYy5zZXE7XG4gICAgbGFzdFNlcSA9IGRvYy5zZXE7XG4gICAgdmFyIGZpbHRlcmVkID0gZmlsdGVyKGNoYW5nZSk7XG5cbiAgICAvLyBJZiBpdHMgYW4gZXJyb3JcbiAgICBpZiAodHlwZW9mIGZpbHRlcmVkID09PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuIG9wdHMuY29tcGxldGUoZmlsdGVyZWQpO1xuICAgIH1cblxuICAgIGlmIChmaWx0ZXJlZCkge1xuICAgICAgcmVjZWl2ZWQrKztcbiAgICAgIGlmIChvcHRzLnJldHVybl9kb2NzKSB7XG4gICAgICAgIHJlc3VsdHMucHVzaChjaGFuZ2UpO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0cy5pbmNsdWRlX2RvY3MgJiYgb3B0cy5hdHRhY2htZW50cyAmJiBkb2MuZGF0YS5fYXR0YWNobWVudHMpIHtcbiAgICAgICAgdmFyIHByb21pc2VzID0gW107XG4gICAgICAgIGZvciAodmFyIG5hbWUgaW4gZG9jLmRhdGEuX2F0dGFjaG1lbnRzKSB7XG4gICAgICAgICAgdmFyIHAgPSBwcm9jZXNzQXR0YWNobWVudChuYW1lLCBkb2MsIGNoYW5nZS5kb2MsIG9wdHMuYmluYXJ5KTtcbiAgICAgICAgICAvLyBXZSBhZGQgdGhlIHByb2Nlc3NpbmcgcHJvbWlzZSB0byAyIGFycmF5cywgb25lIHRyYWNrcyBhbGxcbiAgICAgICAgICAvLyB0aGUgcHJvbWlzZXMgbmVlZGVkIGJlZm9yZSB3ZSBmaXJlIG9uQ2hhbmdlLCB0aGUgb3RoZXJcbiAgICAgICAgICAvLyBlbnN1cmUgd2UgcHJvY2VzcyBhbGwgYXR0YWNobWVudHMgYmVmb3JlIG9uQ29tcGxldGVcbiAgICAgICAgICBwcm9taXNlcy5wdXNoKHApO1xuICAgICAgICAgIHByb2Nlc3NpbmcucHVzaChwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIFByb21pc2UuYWxsKHByb21pc2VzKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBvcHRzLm9uQ2hhbmdlKGNoYW5nZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3B0cy5vbkNoYW5nZShjaGFuZ2UpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocmVjZWl2ZWQgIT09IGxpbWl0KSB7XG4gICAgICBjdXJzb3IuY29udGludWUoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvblR4bkNvbXBsZXRlKCkge1xuICAgIFByb21pc2UuYWxsKHByb2Nlc3NpbmcpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgb3B0cy5jb21wbGV0ZShudWxsLCB7XG4gICAgICAgIHJlc3VsdHM6IHJlc3VsdHMsXG4gICAgICAgIGxhc3Rfc2VxOiBsYXN0U2VxXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIHZhciByZXE7XG4gIGlmIChvcHRzLmRlc2NlbmRpbmcpIHtcbiAgICByZXEgPSBzdG9yZS5vcGVuQ3Vyc29yKG51bGwsICdwcmV2Jyk7XG4gIH0gZWxzZSB7XG4gICAgcmVxID0gc3RvcmUub3BlbkN1cnNvcihJREJLZXlSYW5nZS5sb3dlckJvdW5kKG9wdHMuc2luY2UsIHRydWUpKTtcbiAgfVxuXG4gIHR4bi50eG4ub25jb21wbGV0ZSA9IG9uVHhuQ29tcGxldGU7XG4gIHJlcS5vbnN1Y2Nlc3MgPSBvblJlcVN1Y2Nlc3M7XG59XG5cbmZ1bmN0aW9uIGdldFJldmlzaW9uVHJlZSAodHhuLCBpZCwgY2FsbGJhY2spIHtcbiAgaWYgKHR4bi5lcnJvcikge1xuICAgIHJldHVybiBjYWxsYmFjayh0eG4uZXJyb3IpO1xuICB9XG5cbiAgdmFyIHJlcSA9IHR4bi50eG4ub2JqZWN0U3RvcmUoRE9DX1NUT1JFKS5nZXQoaWQpO1xuICByZXEub25zdWNjZXNzID0gZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoIWUudGFyZ2V0LnJlc3VsdCkge1xuICAgICAgY2FsbGJhY2soY3JlYXRlRXJyb3IoTUlTU0lOR19ET0MpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FsbGJhY2sobnVsbCwgZS50YXJnZXQucmVzdWx0LnJldl90cmVlKTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGRvQ29tcGFjdGlvbiAodHhuLCBpZCwgcmV2cywgY2FsbGJhY2spIHtcbiAgaWYgKHR4bi5lcnJvcikge1xuICAgIHJldHVybiBjYWxsYmFjayh0eG4uZXJyb3IpO1xuICB9XG5cbiAgdmFyIGRvY1N0b3JlID0gdHhuLnR4bi5vYmplY3RTdG9yZShET0NfU1RPUkUpO1xuXG4gIGRvY1N0b3JlLmdldChpZCkub25zdWNjZXNzID0gZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgZG9jID0gZS50YXJnZXQucmVzdWx0O1xuXG4gICAgdHJhdmVyc2VSZXZUcmVlKGRvYy5yZXZfdHJlZSwgZnVuY3Rpb24gKGlzTGVhZiwgcG9zLCByZXZIYXNoLCBjdHgsIG9wdHMpIHtcbiAgICAgIHZhciByZXYgPSBwb3MgKyAnLScgKyByZXZIYXNoO1xuICAgICAgaWYgKHJldnMuaW5kZXhPZihyZXYpICE9PSAtMSkge1xuICAgICAgICBvcHRzLnN0YXR1cyA9ICdtaXNzaW5nJztcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHZhciBhdHRhY2htZW50cyA9IFtdO1xuXG4gICAgcmV2cy5mb3JFYWNoKGZ1bmN0aW9uIChyZXYpIHtcbiAgICAgIGlmIChyZXYgaW4gZG9jLnJldnMpIHtcbiAgICAgICAgLy8gTWFrZSBhIGxpc3Qgb2YgYXR0YWNobWVudHMgdGhhdCBhcmUgdXNlZCBieSB0aGUgcmV2aXNpb25zIGJlaW5nXG4gICAgICAgIC8vIGRlbGV0ZWRcbiAgICAgICAgaWYgKGRvYy5yZXZzW3Jldl0uZGF0YS5fYXR0YWNobWVudHMpIHtcbiAgICAgICAgICBmb3IgKHZhciBrIGluIGRvYy5yZXZzW3Jldl0uZGF0YS5fYXR0YWNobWVudHMpIHtcbiAgICAgICAgICAgIGF0dGFjaG1lbnRzLnB1c2goZG9jLnJldnNbcmV2XS5kYXRhLl9hdHRhY2htZW50c1trXS5kaWdlc3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgZG9jLnJldnNbcmV2XTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIEF0dGFjaG1lbnRzIGhhdmUgYSBsaXN0IG9mIHJldmlzaW9ucyB0aGF0IGFyZSB1c2luZyB0aGVtLCB3aGVuXG4gICAgLy8gdGhhdCBsaXN0IGJlY29tZXMgZW1wdHkgd2UgY2FuIGRlbGV0ZSB0aGUgYXR0YWNobWVudC5cbiAgICBhdHRhY2htZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChkaWdlc3QpIHtcbiAgICAgIHJldnMuZm9yRWFjaChmdW5jdGlvbiAocmV2KSB7XG4gICAgICAgIGRlbGV0ZSBkb2MuYXR0YWNobWVudHNbZGlnZXN0XS5yZXZzW3Jldl07XG4gICAgICB9KTtcbiAgICAgIGlmICghT2JqZWN0LmtleXMoZG9jLmF0dGFjaG1lbnRzW2RpZ2VzdF0ucmV2cykubGVuZ3RoKSB7XG4gICAgICAgIGRlbGV0ZSBkb2MuYXR0YWNobWVudHNbZGlnZXN0XTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGRvY1N0b3JlLnB1dChkb2MpO1xuICB9O1xuXG4gIHR4bi50eG4ub25jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBjYWxsYmFjaygpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBkZXN0cm95IChkYk9wdHMsIG9wZW5EYXRhYmFzZXMsIGlkYkNoYW5nZXMsIGNhbGxiYWNrKSB7XG5cbiAgaWRiQ2hhbmdlcy5yZW1vdmVBbGxMaXN0ZW5lcnMoZGJPcHRzLm5hbWUpO1xuXG4gIGZ1bmN0aW9uIGRvRGVzdHJveSgpIHtcbiAgICB2YXIgcmVxID0gaW5kZXhlZERCLmRlbGV0ZURhdGFiYXNlKGRiT3B0cy5uYW1lKTtcbiAgICByZXEub25zdWNjZXNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgZGVsZXRlIG9wZW5EYXRhYmFzZXNbZGJPcHRzLm5hbWVdO1xuICAgICAgY2FsbGJhY2sobnVsbCwge29rOiB0cnVlfSk7XG4gICAgfTtcbiAgfVxuXG4gIC8vIElmIHRoZSBkYXRhYmFzZSBpcyBvcGVuIHdlIG5lZWQgdG8gY2xvc2UgaXRcbiAgaWYgKGRiT3B0cy5uYW1lIGluIG9wZW5EYXRhYmFzZXMpIHtcbiAgICBvcGVuRGF0YWJhc2VzW2RiT3B0cy5uYW1lXS50aGVuKGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgIHJlcy5pZGIuY2xvc2UoKTtcbiAgICAgIGRvRGVzdHJveSgpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGRvRGVzdHJveSgpO1xuICB9XG5cbn1cblxuLy8gQWRhcHRlZCBmcm9tXG4vLyBodHRwczovL2dpdGh1Yi5jb20vcG91Y2hkYi9wb3VjaGRiL2Jsb2IvbWFzdGVyL3BhY2thZ2VzL25vZGVfbW9kdWxlcy9wb3VjaGRiLWZpbmQvc3JjL2FkYXB0ZXJzL2xvY2FsL2ZpbmQvcXVlcnktcGxhbm5lci5qcyNMMjAtTDI0XG4vLyBUaGlzIGNvdWxkIGNoYW5nZSAvIGltcHJvdmUgaW4gdGhlIGZ1dHVyZT9cbnZhciBDT1VDSF9DT0xMQVRFX0xPID0gbnVsbDtcbnZhciBDT1VDSF9DT0xMQVRFX0hJID0gJ1xcdWZmZmYnOyAvLyBhY3R1YWxseSB1c2VkIGFzIHtcIlxcdWZmZmZcIjoge319XG5cbi8vIEFkYXB0ZWQgZnJvbTogaHR0cHM6Ly93d3cudzMub3JnL1RSL0luZGV4ZWREQi8jY29tcGFyZS10d28ta2V5c1xuLy8gSW1wb3J0YW50bHksICp0aGVyZSBpcyBubyB1cHBlciBib3VuZCBwb3NzaWJsZSogaW4gaWRiLiBUaGUgaWRlYWwgZGF0YVxuLy8gc3RydWN0dXJlIGFuIGluZmludGVseSBkZWVwIGFycmF5OlxuLy8gICB2YXIgSURCX0NPTExBVEVfSEkgPSBbXTsgSURCX0NPTExBVEVfSEkucHVzaChJREJfQ09MTEFURV9ISSlcbi8vIEJ1dCBJREJLZXlSYW5nZSBpcyBub3QgYSBmYW4gb2Ygc2hlbmFuaWdhbnMsIHNvIEkndmUganVzdCBnb25lIHdpdGggMTIgbGF5ZXJzXG4vLyBiZWNhdXNlIGl0IGxvb2tzIG5pY2UgYW5kIHN1cmVseSB0aGF0J3MgZW5vdWdoIVxudmFyIElEQl9DT0xMQVRFX0xPID0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO1xudmFyIElEQl9DT0xMQVRFX0hJID0gW1tbW1tbW1tbW1tbXV1dXV1dXV1dXV1dO1xuXG4vL1xuLy8gVE9ETzogdGhpcyBzaG91bGQgYmUgbWFkZSBvZmZpY2FsIHNvbWV3aGVyZSBhbmQgdXNlZCBieSBBbGxEb2NzIC8gZ2V0IC9cbi8vIGNoYW5nZXMgZXRjIGFzIHdlbGwuXG4vL1xuZnVuY3Rpb24gZXh0ZXJuYWxpc2VSZWNvcmQoaWRiRG9jKSB7XG4gIHZhciBkb2MgPSBpZGJEb2MucmV2c1tpZGJEb2MucmV2XS5kYXRhO1xuICBkb2MuX2lkID0gaWRiRG9jLmlkO1xuICBkb2MuX3JldiA9IGlkYkRvYy5yZXY7XG4gIGlmIChpZGJEb2MuZGVsZXRlZCkge1xuICAgIGRvYy5fZGVsZXRlZCA9IHRydWU7XG4gIH1cblxuICByZXR1cm4gZG9jO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlcyBhIGtleXJhbmdlIGJhc2VkIG9uIHRoZSBvcHRzIHBhc3NlZCB0byBxdWVyeVxuICpcbiAqIFRoZSBmaXJzdCBrZXkgaXMgYWx3YXlzIDAsIGFzIHRoYXQncyBob3cgd2UncmUgZmlsdGVyaW5nIG91dCBkZWxldGVkIGVudHJpZXMuXG4gKi9cbmZ1bmN0aW9uIGdlbmVyYXRlS2V5UmFuZ2Uob3B0cykge1xuICBmdW5jdGlvbiBkZWZpbmVkKG9iaiwgaykge1xuICAgIHJldHVybiBvYmpba10gIT09IHZvaWQgMDtcbiAgfVxuXG4gIC8vIENvbnZlcnRzIGEgdmFsaWQgQ291Y2hEQiBrZXkgaW50byBhIHZhbGlkIEluZGV4ZWREQiBvbmVcbiAgZnVuY3Rpb24gY29udmVydChrZXksIGV4YWN0KSB7XG4gICAgLy8gVGhlIGZpcnN0IGl0ZW0gaW4gZXZlcnkgbmF0aXZlIGluZGV4IGlzIGRvYy5kZWxldGVkLCBhbmQgd2UgYWx3YXlzIHdhbnRcbiAgICAvLyB0byBvbmx5IHNlYXJjaCBkb2N1bWVudHMgdGhhdCBhcmUgbm90IGRlbGV0ZWQuXG4gICAgLy8gXCJmb29cIiAtPiBbMCwgXCJmb29cIl1cbiAgICB2YXIgZmlsdGVyRGVsZXRlZCA9IFswXS5jb25jYXQoa2V5KTtcblxuICAgIHJldHVybiBmaWx0ZXJEZWxldGVkLm1hcChmdW5jdGlvbiAoaykge1xuICAgICAgLy8gbnVsbCwgdHJ1ZSBhbmQgZmFsc2UgYXJlIG5vdCBpbmRleGFibGUgYnkgaW5kZXhlZGRiLiBXaGVuIHdlIHdyaXRlXG4gICAgICAvLyB0aGVzZSB2YWx1ZXMgd2UgY29udmVydCB0aGVtIHRvIHRoZXNlIGNvbnN0YW50cywgYW5kIHNvIHdoZW4gd2VcbiAgICAgIC8vIHF1ZXJ5IGZvciB0aGVtIHdlIG5lZWQgdG8gY29udmVydCB0aGUgcXVlcnkgYWxzby5cbiAgICAgIGlmIChrID09PSBudWxsICYmIGV4YWN0KSB7XG4gICAgICAgIC8vIGZvciBub24tZXhhY3QgcXVlcmllcyB3ZSB0cmVhdCBudWxsIGFzIGEgY29sbGF0ZSBwcm9wZXJ0eVxuICAgICAgICAvLyBzZWUgYGlmICghZXhhY3QpYCBibG9jayBiZWxvd1xuICAgICAgICByZXR1cm4gSURCX05VTEw7XG4gICAgICB9IGVsc2UgaWYgKGsgPT09IHRydWUpIHtcbiAgICAgICAgcmV0dXJuIElEQl9UUlVFO1xuICAgICAgfSBlbHNlIGlmIChrID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gSURCX0ZBTFNFO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWV4YWN0KSB7XG4gICAgICAgIC8vIFdlIGdldCBwYXNzZWQgQ291Y2hEQidzIGNvbGxhdGUgbG93IGFuZCBoaWdoIHZhbHVlcywgc28gZm9yIG5vbi1leGFjdFxuICAgICAgICAvLyByYW5nZWQgcXVlcmllcyB3ZSdyZSBnb2luZyB0byBjb252ZXJ0IHRoZW0gdG8gb3VyIElEQiBlcXVpdmFsZW50c1xuICAgICAgICBpZiAoayA9PT0gQ09VQ0hfQ09MTEFURV9MTykge1xuICAgICAgICAgIHJldHVybiBJREJfQ09MTEFURV9MTztcbiAgICAgICAgfSBlbHNlIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoaywgQ09VQ0hfQ09MTEFURV9ISSkpIHtcbiAgICAgICAgICByZXR1cm4gSURCX0NPTExBVEVfSEk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGs7XG4gICAgfSk7XG4gIH1cblxuICAvLyBDb3VjaERCIGFuZCBzbyBQb3VjaGRCIGRlZmF1bHRzIHRvIHRydWUuIFdlIG5lZWQgdG8gbWFrZSB0aGlzIGV4cGxpY2l0IGFzXG4gIC8vIHdlIGludmVydCB0aGVzZSBsYXRlciBmb3IgSW5kZXhlZERCLlxuICBpZiAoIWRlZmluZWQob3B0cywgJ2luY2x1c2l2ZV9lbmQnKSkge1xuICAgIG9wdHMuaW5jbHVzaXZlX2VuZCA9IHRydWU7XG4gIH1cbiAgaWYgKCFkZWZpbmVkKG9wdHMsICdpbmNsdXNpdmVfc3RhcnQnKSkge1xuICAgIG9wdHMuaW5jbHVzaXZlX3N0YXJ0ID0gdHJ1ZTtcbiAgfVxuXG4gIGlmIChvcHRzLmRlc2NlbmRpbmcpIHtcbiAgICAvLyBGbGlwIGJlZm9yZSBnZW5lcmF0aW5nLiBXZSdsbCBjaGVjayBkZXNjZW5kaW5nIGFnYWluIGxhdGVyIHdoZW4gcGVyZm9ybWluZ1xuICAgIC8vIGFuIGluZGV4IHJlcXVlc3RcbiAgICB2YXIgcmVhbEVuZGtleSA9IG9wdHMuc3RhcnRrZXksXG4gICAgICAgIHJlYWxJbmNsdXNpdmVFbmQgPSBvcHRzLmluY2x1c2l2ZV9zdGFydDtcblxuICAgIG9wdHMuc3RhcnRrZXkgPSBvcHRzLmVuZGtleTtcbiAgICBvcHRzLmVuZGtleSA9IHJlYWxFbmRrZXk7XG4gICAgb3B0cy5pbmNsdXNpdmVfc3RhcnQgPSBvcHRzLmluY2x1c2l2ZV9lbmQ7XG4gICAgb3B0cy5pbmNsdXNpdmVfZW5kID0gcmVhbEluY2x1c2l2ZUVuZDtcbiAgfVxuXG4gIHRyeSB7XG4gICAgaWYgKGRlZmluZWQob3B0cywgJ2tleScpKSB7XG4gICAgICByZXR1cm4gSURCS2V5UmFuZ2Uub25seShjb252ZXJ0KG9wdHMua2V5LCB0cnVlKSk7XG4gICAgfVxuXG4gICAgaWYgKGRlZmluZWQob3B0cywgJ3N0YXJ0a2V5JykgJiYgIWRlZmluZWQob3B0cywgJ2VuZGtleScpKSB7XG4gICAgICByZXR1cm4gSURCS2V5UmFuZ2UubG93ZXJCb3VuZChjb252ZXJ0KG9wdHMuc3RhcnRrZXkpLCAhb3B0cy5pbmNsdXNpdmVfc3RhcnQpO1xuICAgIH1cblxuICAgIGlmICghZGVmaW5lZChvcHRzLCAnc3RhcnRrZXknKSAmJiBkZWZpbmVkKG9wdHMsICdlbmRrZXknKSkge1xuICAgICAgcmV0dXJuIElEQktleVJhbmdlLnVwcGVyQm91bmQoY29udmVydChvcHRzLmVuZGtleSksICFvcHRzLmluY2x1c2l2ZV9lbmQpO1xuICAgIH1cblxuICAgIGlmIChkZWZpbmVkKG9wdHMsICdzdGFydGtleScpICYmIGRlZmluZWQob3B0cywgJ2VuZGtleScpKSB7XG4gICAgICByZXR1cm4gSURCS2V5UmFuZ2UuYm91bmQoXG4gICAgICAgIGNvbnZlcnQob3B0cy5zdGFydGtleSksICAgIGNvbnZlcnQob3B0cy5lbmRrZXkpLFxuICAgICAgICAhb3B0cy5pbmNsdXNpdmVfc3RhcnQsICFvcHRzLmluY2x1c2l2ZV9lbmRcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIElEQktleVJhbmdlLm9ubHkoWzBdKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY29uc29sZS5lcnJvcignQ291bGQgbm90IGdlbmVyYXRlIGtleVJhbmdlJywgZXJyLCBvcHRzKTtcbiAgICB0aHJvdyBFcnJvcignQ291bGQgbm90IGdlbmVyYXRlIGtleSByYW5nZSB3aXRoICcgKyBKU09OLnN0cmluZ2lmeShvcHRzKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0SW5kZXhIYW5kbGUocGRiLCBmaWVsZHMsIHJlamVjdCkge1xuICB2YXIgaW5kZXhOYW1lID0gbmF0dXJhbEluZGV4TmFtZShmaWVsZHMpO1xuXG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgIHBkYi5fb3BlblRyYW5zYWN0aW9uU2FmZWx5KFtET0NfU1RPUkVdLCAncmVhZG9ubHknLCBmdW5jdGlvbiAoZXJyLCB0eG4pIHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIGlkYkVycm9yKHJlamVjdCkoZXJyKTtcbiAgICAgIH1cblxuICAgICAgdHhuLm9uYWJvcnQgPSBpZGJFcnJvcihyZWplY3QpO1xuICAgICAgdHhuLm9udGltZW91dCA9IGlkYkVycm9yKHJlamVjdCk7XG5cbiAgICAgIHZhciBleGlzdGluZ0luZGV4TmFtZXMgPSBBcnJheS5mcm9tKHR4bi5vYmplY3RTdG9yZShET0NfU1RPUkUpLmluZGV4TmFtZXMpO1xuXG4gICAgICBpZiAoZXhpc3RpbmdJbmRleE5hbWVzLmluZGV4T2YoaW5kZXhOYW1lKSA9PT0gLTEpIHtcbiAgICAgICAgLy8gVGhlIGluZGV4IGlzIG1pc3NpbmcsIGZvcmNlIGEgZGIgcmVzdGFydCBhbmQgdHJ5IGFnYWluXG4gICAgICAgIHBkYi5fZnJlc2hlbigpXG4gICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2V0SW5kZXhIYW5kbGUocGRiLCBmaWVsZHMsIHJlamVjdCk7IH0pXG4gICAgICAgICAgLnRoZW4ocmVzb2x2ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXNvbHZlKHR4bi5vYmplY3RTdG9yZShET0NfU1RPUkUpLmluZGV4KGluZGV4TmFtZSkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn1cblxuLy8gSW4gdGhlb3J5IHdlIHNob3VsZCByZXR1cm4gc29tZXRoaW5nIGxpa2UgdGhlIGRvYyBleGFtcGxlIGJlbG93LCBidXQgZmluZFxuLy8gb25seSBuZWVkcyByb3dzOiBbe2RvYzogey4uLn19XSwgc28gSSB0aGluayB3ZSBjYW4ganVzdCBub3QgYm90aGVyIGZvciBub3dcbi8vIHtcbi8vICAgXCJvZmZzZXRcIiA6IDAsXG4vLyAgIFwicm93c1wiOiBbe1xuLy8gICAgIFwiaWRcIjogXCJkb2MzXCIsXG4vLyAgICAgXCJrZXlcIjogXCJMaXNhIFNheXNcIixcbi8vICAgICBcInZhbHVlXCI6IG51bGwsXG4vLyAgICAgXCJkb2NcIjoge1xuLy8gICAgICAgXCJfaWRcIjogXCJkb2MzXCIsXG4vLyAgICAgICBcIl9yZXZcIjogXCIxLXpcIixcbi8vICAgICAgIFwidGl0bGVcIjogXCJMaXNhIFNheXNcIlxuLy8gICAgIH1cbi8vICAgfV0sXG4vLyAgIFwidG90YWxfcm93c1wiIDogNFxuLy8gfVxuZnVuY3Rpb24gcXVlcnkoaWRiLCBzaWduYXR1cmUsIG9wdHMpIHtcbiAgLy8gQXQgdGhpcyBzdGFnZSwgaW4gdGhlIGN1cnJlbnQgaW1wbGVtZW50YXRpb24sIGZpbmQgaGFzIGFscmVhZHkgZ29uZSB0aHJvdWdoXG4gIC8vIGFuZCBkZXRlcm1pbmVkIGlmIHRoZSBpbmRleCBhbHJlYWR5IGV4aXN0cyBmcm9tIFBvdWNoREIncyBwZXJzcGVjdGl2ZSAoZWdcbiAgLy8gdGhlcmUgaXMgYSBkZXNpZ24gZG9jIGZvciBpdCkuXG4gIC8vXG4gIC8vIElmIHdlIGZpbmQgdGhhdCB0aGUgaW5kZXggZG9lc24ndCBleGlzdCB0aGlzIG1lYW5zIHdlIGhhdmUgdG8gY2xvc2UgYW5kXG4gIC8vIHJlLW9wZW4gdGhlIERCIHRvIGNvcnJlY3QgaW5kZXhlcyBiZWZvcmUgcHJvY2VlZGluZywgYXQgd2hpY2ggcG9pbnQgdGhlXG4gIC8vIGluZGV4IHNob3VsZCBleGlzdC5cblxuICB2YXIgcGRiID0gdGhpcztcblxuICAvLyBBc3N1bXB0aW9uLCB0aGVyZSB3aWxsIGJlIG9ubHkgb25lIC8sIGJldHdlZW4gdGhlIGRlc2lnbiBkb2N1bWVudCBuYW1lXG4gIC8vIGFuZCB0aGUgdmlldyBuYW1lLlxuICB2YXIgcGFydHMgPSBzaWduYXR1cmUuc3BsaXQoJy8nKTtcblxuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIHBkYi5nZXQoJ19kZXNpZ24vJyArIHBhcnRzWzBdKS50aGVuKGZ1bmN0aW9uIChkZG9jKSB7XG4gICAgICB2YXIgZmllbGRzID0gcmF3SW5kZXhGaWVsZHMoZGRvYywgcGFydHNbMV0pO1xuICAgICAgaWYgKCFmaWVsZHMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkZG9jICcgKyBkZG9jLl9pZCArJyB3aXRoIHZpZXcgJyArIHBhcnRzWzFdICtcbiAgICAgICAgICAnIGRvZXMgbm90IGhhdmUgbWFwLm9wdGlvbnMuZGVmLmZpZWxkcyBkZWZpbmVkLicpO1xuICAgICAgfVxuXG4gICAgICB2YXIgc2tpcCA9IG9wdHMuc2tpcDtcbiAgICAgIHZhciBsaW1pdCA9IE51bWJlci5pc0ludGVnZXIob3B0cy5saW1pdCkgJiYgb3B0cy5saW1pdDtcblxuICAgICAgcmV0dXJuIGdldEluZGV4SGFuZGxlKHBkYiwgZmllbGRzLCByZWplY3QpXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uIChpbmRleEhhbmRsZSkge1xuICAgICAgICAgIHZhciBrZXlSYW5nZSA9IGdlbmVyYXRlS2V5UmFuZ2Uob3B0cyk7XG4gICAgICAgICAgdmFyIHJlcSA9IGluZGV4SGFuZGxlLm9wZW5DdXJzb3Ioa2V5UmFuZ2UsIG9wdHMuZGVzY2VuZGluZyA/ICdwcmV2JyA6ICduZXh0Jyk7XG5cbiAgICAgICAgICB2YXIgcm93cyA9IFtdO1xuICAgICAgICAgIHJlcS5vbmVycm9yID0gaWRiRXJyb3IocmVqZWN0KTtcbiAgICAgICAgICByZXEub25zdWNjZXNzID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHZhciBjdXJzb3IgPSBlLnRhcmdldC5yZXN1bHQ7XG5cbiAgICAgICAgICAgIGlmICghY3Vyc29yIHx8IGxpbWl0ID09PSAwKSB7XG4gICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKHtcbiAgICAgICAgICAgICAgICByb3dzOiByb3dzXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc2tpcCkge1xuICAgICAgICAgICAgICBjdXJzb3IuYWR2YW5jZShza2lwKTtcbiAgICAgICAgICAgICAgc2tpcCA9IGZhbHNlO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChsaW1pdCkge1xuICAgICAgICAgICAgICBsaW1pdCA9IGxpbWl0IC0gMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcm93cy5wdXNoKHtkb2M6IGV4dGVybmFsaXNlUmVjb3JkKGN1cnNvci52YWx1ZSl9KTtcbiAgICAgICAgICAgIGN1cnNvci5jb250aW51ZSgpO1xuICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgfSlcbiAgICAgIC5jYXRjaChyZWplY3QpO1xuICB9KTtcblxufVxuXG5mdW5jdGlvbiB2aWV3Q2xlYW51cCgpIHtcbiAgLy8gSSdtIG5vdCBzdXJlIHdlIGhhdmUgdG8gZG8gYW55dGhpbmcgaGVyZS5cbiAgLy9cbiAgLy8gT25lIG9wdGlvbiBpcyB0byBqdXN0IGNsb3NlIGFuZCByZS1vcGVuIHRoZSBEQiwgd2hpY2ggcGVyZm9ybXMgdGhlIHNhbWVcbiAgLy8gYWN0aW9uLiBUaGUgb25seSByZWFzb24geW91J2Qgd2FudCB0byBjYWxsIHRoaXMgaXMgaWYgeW91IGRlbGV0ZWQgYSBidW5jaFxuICAvLyBvZiBpbmRleGVzIGFuZCB3YW50ZWQgdGhlIHNwYWNlIGJhY2sgaW1tZWRpYXRlbHkuXG4gIC8vXG4gIC8vIE90aGVyd2lzZSBpbmRleCBjbGVhbnVwIGhhcHBlbnMgd2hlbjpcbiAgLy8gIC0gQSBEQiBpcyBvcGVuZWRcbiAgLy8gIC0gQSBmaW5kIHF1ZXJ5IGlzIHBlcmZvcm1lZCBhZ2FpbnN0IGFuIGluZGV4IHRoYXQgZG9lc24ndCBleGlzdCBidXQgc2hvdWxkXG5cbiAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xufVxuXG52YXIgQURBUFRFUl9OQU1FID0gJ2luZGV4ZWRkYic7XG5cbi8vIFRPRE86IENvbnN0cnVjdG9yIHNob3VsZCBiZSBjYXBpdGFsaXNlZFxudmFyIGlkYkNoYW5nZXMgPSBuZXcgY2hhbmdlc0hhbmRsZXIoKTtcblxuLy8gQSBzaGFyZWQgbGlzdCBvZiBkYXRhYmFzZSBoYW5kbGVzXG52YXIgb3BlbkRhdGFiYXNlcyA9IHt9O1xuXG5mdW5jdGlvbiBJZGJQb3VjaChkYk9wdHMsIGNhbGxiYWNrKSB7XG5cbiAgaWYgKGRiT3B0cy52aWV3X2FkYXB0ZXIpIHtcbiAgICBjb25zb2xlLmxvZygnUGxlYXNlIG5vdGUgdGhhdCB0aGUgaW5kZXhlZGRiIGFkYXB0ZXIgbWFuYWdlcyBfZmluZCBpbmRleGVzIGl0c2VsZiwgdGhlcmVmb3JlIGl0IGlzIG5vdCB1c2luZyB5b3VyIHNwZWNpZmllZCB2aWV3X2FkYXB0ZXInKTtcbiAgfVxuICBcbiAgdmFyIGFwaSA9IHRoaXM7XG4gIHZhciBtZXRhZGF0YSA9IHt9O1xuXG4gIC8vIFdyYXBwZXIgdGhhdCBnaXZlcyB5b3UgYW4gYWN0aXZlIERCIGhhbmRsZS4gWW91IHByb2JhYmx5IHdhbnQgJHQuXG4gIHZhciAkID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICBzZXR1cChvcGVuRGF0YWJhc2VzLCBhcGksIGRiT3B0cykudGhlbihmdW5jdGlvbiAocmVzKSB7XG4gICAgICAgIG1ldGFkYXRhID0gcmVzLm1ldGFkYXRhO1xuICAgICAgICBhcmdzLnVuc2hpZnQocmVzLmlkYik7XG4gICAgICAgIGZ1bi5hcHBseShhcGksIGFyZ3MpO1xuICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKGVycikge1xuICAgICAgICB2YXIgbGFzdCA9IGFyZ3MucG9wKCk7XG4gICAgICAgIGlmICh0eXBlb2YgbGFzdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGxhc3QoZXJyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG4gIH07XG4gIC8vIHRoZSBwcm9taXNlIHZlcnNpb24gb2YgJFxuICB2YXIgJHAgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcblxuICAgICAgcmV0dXJuIHNldHVwKG9wZW5EYXRhYmFzZXMsIGFwaSwgZGJPcHRzKS50aGVuKGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgICAgbWV0YWRhdGEgPSByZXMubWV0YWRhdGE7XG4gICAgICAgIGFyZ3MudW5zaGlmdChyZXMuaWRiKTtcblxuICAgICAgICByZXR1cm4gZnVuLmFwcGx5KGFwaSwgYXJncyk7XG4gICAgICB9KTtcbiAgICB9O1xuICB9O1xuICAvLyBXcmFwcGVyIHRoYXQgZ2l2ZXMgeW91IGEgc2FmZSB0cmFuc2FjdGlvbiBoYW5kbGUuIEl0J3MgaW1wb3J0YW50IHRvIHVzZVxuICAvLyB0aGlzIGluc3RlYWQgb2Ygb3BlbmluZyB5b3VyIG93biB0cmFuc2FjdGlvbiBmcm9tIGEgZGIgaGFuZGxlIGdvdCBmcm9tICQsXG4gIC8vIGJlY2F1c2UgaW4gdGhlIHRpbWUgYmV0d2VlbiBnZXR0aW5nIHRoZSBkYiBoYW5kbGUgYW5kIG9wZW5pbmcgdGhlXG4gIC8vIHRyYW5zYWN0aW9uIGl0IG1heSBoYXZlIGJlZW4gaW52YWxpZGF0ZWQgYnkgaW5kZXggY2hhbmdlcy5cbiAgdmFyICR0ID0gZnVuY3Rpb24gKGZ1biwgc3RvcmVzLCBtb2RlKSB7XG4gICAgc3RvcmVzID0gc3RvcmVzIHx8IFtET0NfU1RPUkVdO1xuICAgIG1vZGUgPSBtb2RlIHx8ICdyZWFkb25seSc7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgdmFyIHR4biA9IHt9O1xuICAgICAgc2V0dXAob3BlbkRhdGFiYXNlcywgYXBpLCBkYk9wdHMpLnRoZW4oZnVuY3Rpb24gKHJlcykge1xuICAgICAgICBtZXRhZGF0YSA9IHJlcy5tZXRhZGF0YTtcbiAgICAgICAgdHhuLnR4biA9IHJlcy5pZGIudHJhbnNhY3Rpb24oc3RvcmVzLCBtb2RlKTtcbiAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGVzdGFibGlzaCB0cmFuc2FjdGlvbiBzYWZlbHknKTtcbiAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgICB0eG4uZXJyb3IgPSBlcnI7XG4gICAgICB9KS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgYXJncy51bnNoaWZ0KHR4bik7XG4gICAgICAgIGZ1bi5hcHBseShhcGksIGFyZ3MpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgfTtcblxuICBhcGkuX29wZW5UcmFuc2FjdGlvblNhZmVseSA9IGZ1bmN0aW9uIChzdG9yZXMsIG1vZGUsIGNhbGxiYWNrKSB7XG4gICAgJHQoZnVuY3Rpb24gKHR4biwgY2FsbGJhY2spIHtcbiAgICAgIGNhbGxiYWNrKHR4bi5lcnJvciwgdHhuLnR4bik7XG4gICAgfSwgc3RvcmVzLCBtb2RlKShjYWxsYmFjayk7XG4gIH07XG5cbiAgYXBpLl9yZW1vdGUgPSBmYWxzZTtcbiAgYXBpLnR5cGUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBBREFQVEVSX05BTUU7IH07XG5cbiAgYXBpLl9pZCA9ICQoZnVuY3Rpb24gKF8sIGNiKSB7XG4gICAgY2IobnVsbCwgbWV0YWRhdGEuZGJfdXVpZCk7XG4gIH0pO1xuXG4gIGFwaS5faW5mbyA9ICQoZnVuY3Rpb24gKF8sIGNiKSB7XG4gICAgcmV0dXJuIGluZm8obWV0YWRhdGEsIGNiKTtcbiAgfSk7XG5cbiAgYXBpLl9nZXQgPSAkdChnZXQpO1xuXG4gIGFwaS5fYnVsa0RvY3MgPSAkKGZ1bmN0aW9uIChfLCByZXEsIG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgYnVsa0RvY3MoYXBpLCByZXEsIG9wdHMsIG1ldGFkYXRhLCBkYk9wdHMsIGlkYkNoYW5nZXMsIGNhbGxiYWNrKTtcbiAgfSk7XG5cbiAgYXBpLl9hbGxEb2NzID0gJHQoZnVuY3Rpb24gKHR4biwgb3B0cywgY2IpIHtcbiAgICBhbGxEb2NzKHR4biwgbWV0YWRhdGEsIG9wdHMsIGNiKTtcbiAgfSk7XG5cbiAgYXBpLl9nZXRBdHRhY2htZW50ID0gJHQoZ2V0QXR0YWNobWVudCk7XG5cbiAgYXBpLl9jaGFuZ2VzID0gJHQoZnVuY3Rpb24gKHR4biwgb3B0cykge1xuICAgIGNoYW5nZXModHhuLCBpZGJDaGFuZ2VzLCBhcGksIGRiT3B0cywgb3B0cyk7XG4gIH0pO1xuXG4gIGFwaS5fZ2V0UmV2aXNpb25UcmVlID0gJHQoZ2V0UmV2aXNpb25UcmVlKTtcbiAgYXBpLl9kb0NvbXBhY3Rpb24gPSAkdChkb0NvbXBhY3Rpb24sIFtET0NfU1RPUkVdLCAncmVhZHdyaXRlJyk7XG5cbiAgYXBpLl9jdXN0b21GaW5kQWJzdHJhY3RNYXBwZXIgPSB7XG4gICAgcXVlcnk6ICRwKHF1ZXJ5KSxcbiAgICB2aWV3Q2xlYW51cDogJHAodmlld0NsZWFudXApXG4gIH07XG5cbiAgYXBpLl9kZXN0cm95ID0gZnVuY3Rpb24gKG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIGRlc3Ryb3koZGJPcHRzLCBvcGVuRGF0YWJhc2VzLCBpZGJDaGFuZ2VzLCBjYWxsYmFjayk7XG4gIH07XG5cbiAgYXBpLl9jbG9zZSA9ICQoZnVuY3Rpb24gKGRiLCBjYikge1xuICAgIGRlbGV0ZSBvcGVuRGF0YWJhc2VzW2RiT3B0cy5uYW1lXTtcbiAgICBkYi5jbG9zZSgpO1xuICAgIGNiKCk7XG4gIH0pO1xuXG4gIC8vIENsb3NpbmcgYW5kIHJlLW9wZW5pbmcgdGhlIERCIHJlLWdlbmVyYXRlcyBuYXRpdmUgaW5kZXhlc1xuICBhcGkuX2ZyZXNoZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICBhcGkuX2Nsb3NlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgJChyZXNvbHZlKSgpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gVE9ETzogdGhpcyBzZXRUaW1lb3V0IHNlZW1zIG5hc3R5LCBpZiBpdHMgbmVlZGVkIGxldHNcbiAgLy8gZmlndXJlIG91dCAvIGV4cGxhaW4gd2h5XG4gIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIGNhbGxiYWNrKG51bGwsIGFwaSk7XG4gIH0pO1xufVxuXG4vLyBUT0RPOiB0aGlzIGlzbnQgcmVhbGx5IHZhbGlkIHBlcm1hbmVudGx5LCBqdXN0IGJlaW5nIGxhenkgdG8gc3RhcnRcbklkYlBvdWNoLnZhbGlkID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cbmZ1bmN0aW9uIGluZGV4IChQb3VjaERCKSB7XG4gIFBvdWNoREIuYWRhcHRlcihBREFQVEVSX05BTUUsIElkYlBvdWNoLCB0cnVlKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaW5kZXg7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/pouchdb-adapter-indexeddb/lib/index.es.js\n");

/***/ })

}]);